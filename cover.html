
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>checkpoint: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">gopkg.in/k8snetworkplumbingwg/multus-cni.v3/pkg/checkpoint/checkpoint.go (93.3%)</option>
				
				<option value="file1">gopkg.in/k8snetworkplumbingwg/multus-cni.v3/pkg/k8sclient/k8sclient.go (70.5%)</option>
				
				<option value="file2">gopkg.in/k8snetworkplumbingwg/multus-cni.v3/pkg/kubeletclient/kubeletclient.go (84.9%)</option>
				
				<option value="file3">gopkg.in/k8snetworkplumbingwg/multus-cni.v3/pkg/logging/logging.go (98.3%)</option>
				
				<option value="file4">gopkg.in/k8snetworkplumbingwg/multus-cni.v3/pkg/multus/multus.go (73.5%)</option>
				
				<option value="file5">gopkg.in/k8snetworkplumbingwg/multus-cni.v3/pkg/netutils/netutils.go (72.2%)</option>
				
				<option value="file6">gopkg.in/k8snetworkplumbingwg/multus-cni.v3/pkg/server/config/generator.go (85.7%)</option>
				
				<option value="file7">gopkg.in/k8snetworkplumbingwg/multus-cni.v3/pkg/server/config/manager.go (69.4%)</option>
				
				<option value="file8">gopkg.in/k8snetworkplumbingwg/multus-cni.v3/pkg/server/exec_chroot.go (63.5%)</option>
				
				<option value="file9">gopkg.in/k8snetworkplumbingwg/multus-cni.v3/pkg/server/server.go (70.0%)</option>
				
				<option value="file10">gopkg.in/k8snetworkplumbingwg/multus-cni.v3/pkg/server/shim.go (69.8%)</option>
				
				<option value="file11">gopkg.in/k8snetworkplumbingwg/multus-cni.v3/pkg/server/socket.go (66.7%)</option>
				
				<option value="file12">gopkg.in/k8snetworkplumbingwg/multus-cni.v3/pkg/types/conf.go (72.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Copyright (c) 2018 Intel Corporation
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

package checkpoint

import (
        "encoding/json"
        "io/ioutil"

        "gopkg.in/k8snetworkplumbingwg/multus-cni.v3/pkg/logging"
        "gopkg.in/k8snetworkplumbingwg/multus-cni.v3/pkg/types"
        v1 "k8s.io/api/core/v1"
)

const (
        checkPointfile = "/var/lib/kubelet/device-plugins/kubelet_internal_checkpoint"
)

// PodDevicesEntry maps PodUID, resource name and allocated device id
type PodDevicesEntry struct {
        PodUID        string
        ContainerName string
        ResourceName  string
        DeviceIDs     map[int64][]string
        AllocResp     []byte
}

type checkpointData struct {
        PodDeviceEntries  []PodDevicesEntry
        RegisteredDevices map[string][]string
}

type checkpointFileData struct {
        Data     checkpointData
        Checksum uint64
}

type checkpoint struct {
        fileName   string
        podEntires []PodDevicesEntry
}

// GetCheckpoint returns an instance of Checkpoint
func GetCheckpoint() (types.ResourceClient, error) <span class="cov0" title="0">{
        logging.Debugf("GetCheckpoint(): invoked")
        return getCheckpoint(checkPointfile)
}</span>

func getCheckpoint(filePath string) (types.ResourceClient, error) <span class="cov8" title="1">{
        cp := &amp;checkpoint{fileName: filePath}
        err := cp.getPodEntries()
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">logging.Debugf("getCheckpoint: created checkpoint instance with file: %s", filePath)
        return cp, nil</span>
}

// getPodEntries gets all Pod device allocation entries from checkpoint file
func (cp *checkpoint) getPodEntries() error <span class="cov8" title="1">{

        cpd := &amp;checkpointFileData{}
        rawBytes, err := ioutil.ReadFile(cp.fileName)
        if err != nil </span><span class="cov8" title="1">{
                return logging.Errorf("getPodEntries: error reading file %s\n%v\n", checkPointfile, err)
        }</span>

        <span class="cov8" title="1">if err = json.Unmarshal(rawBytes, cpd); err != nil </span><span class="cov8" title="1">{
                return logging.Errorf("getPodEntries: error unmarshalling raw bytes %v", err)
        }</span>

        <span class="cov8" title="1">cp.podEntires = cpd.Data.PodDeviceEntries
        logging.Debugf("getPodEntries: podEntires %+v", cp.podEntires)
        return nil</span>
}

// GetComputeDeviceMap returns an instance of a map of ResourceInfo
func (cp *checkpoint) GetPodResourceMap(pod *v1.Pod) (map[string]*types.ResourceInfo, error) <span class="cov8" title="1">{
        podID := string(pod.UID)
        resourceMap := make(map[string]*types.ResourceInfo)

        if podID == "" </span><span class="cov8" title="1">{
                return nil, logging.Errorf("GetPodResourceMap: invalid Pod cannot be empty")
        }</span>
        <span class="cov8" title="1">for _, pod := range cp.podEntires </span><span class="cov8" title="1">{
                if pod.PodUID == podID </span><span class="cov8" title="1">{
                        entry, ok := resourceMap[pod.ResourceName]
                        if !ok </span><span class="cov8" title="1">{
                                // new entry
                                entry = &amp;types.ResourceInfo{}
                                resourceMap[pod.ResourceName] = entry
                        }</span>
                        <span class="cov8" title="1">for _, v := range pod.DeviceIDs </span><span class="cov8" title="1">{
                                // already exists; append to it
                                entry.DeviceIDs = append(entry.DeviceIDs, v...)
                        }</span>
                }
        }
        <span class="cov8" title="1">return resourceMap, nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">// Copyright (c) 2017 Intel Corporation
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package k8sclient

import (
        "context"
        "encoding/json"
        "fmt"
        "net"
        "os"
        "regexp"
        "strings"
        "time"

        v1 "k8s.io/api/core/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/client-go/kubernetes"
        "k8s.io/client-go/kubernetes/scheme"
        v1core "k8s.io/client-go/kubernetes/typed/core/v1"
        "k8s.io/client-go/rest"
        "k8s.io/client-go/tools/clientcmd"
        "k8s.io/client-go/tools/record"
        "k8s.io/klog"

        "github.com/containernetworking/cni/libcni"
        "github.com/containernetworking/cni/pkg/skel"
        cnitypes "github.com/containernetworking/cni/pkg/types"
        nettypes "github.com/k8snetworkplumbingwg/network-attachment-definition-client/pkg/apis/k8s.cni.cncf.io/v1"
        netclient "github.com/k8snetworkplumbingwg/network-attachment-definition-client/pkg/client/clientset/versioned/typed/k8s.cni.cncf.io/v1"
        netutils "github.com/k8snetworkplumbingwg/network-attachment-definition-client/pkg/utils"
        "gopkg.in/k8snetworkplumbingwg/multus-cni.v3/pkg/kubeletclient"
        "gopkg.in/k8snetworkplumbingwg/multus-cni.v3/pkg/logging"
        "gopkg.in/k8snetworkplumbingwg/multus-cni.v3/pkg/types"
)

const (
        resourceNameAnnot      = "k8s.v1.cni.cncf.io/resourceName"
        defaultNetAnnot        = "v1.multus-cni.io/default-network"
        networkAttachmentAnnot = "k8s.v1.cni.cncf.io/networks"
)

// NoK8sNetworkError indicates error, no network in kubernetes
type NoK8sNetworkError struct {
        message string
}

// ClientInfo contains information given from k8s client
type ClientInfo struct {
        Client           kubernetes.Interface
        NetClient        netclient.K8sCniCncfIoV1Interface
        EventBroadcaster record.EventBroadcaster
        EventRecorder    record.EventRecorder
}

// AddPod adds pod into kubernetes
func (c *ClientInfo) AddPod(pod *v1.Pod) (*v1.Pod, error) <span class="cov8" title="1">{
        return c.Client.CoreV1().Pods(pod.ObjectMeta.Namespace).Create(context.TODO(), pod, metav1.CreateOptions{})
}</span>

// GetPod gets pod from kubernetes
func (c *ClientInfo) GetPod(namespace, name string) (*v1.Pod, error) <span class="cov8" title="1">{
        return c.Client.CoreV1().Pods(namespace).Get(context.TODO(), name, metav1.GetOptions{})
}</span>

// DeletePod deletes a pod from kubernetes
func (c *ClientInfo) DeletePod(namespace, name string) error <span class="cov0" title="0">{
        return c.Client.CoreV1().Pods(namespace).Delete(context.TODO(), name, metav1.DeleteOptions{})
}</span>

// AddNetAttachDef adds net-attach-def into kubernetes
func (c *ClientInfo) AddNetAttachDef(netattach *nettypes.NetworkAttachmentDefinition) (*nettypes.NetworkAttachmentDefinition, error) <span class="cov8" title="1">{
        return c.NetClient.NetworkAttachmentDefinitions(netattach.ObjectMeta.Namespace).Create(context.TODO(), netattach, metav1.CreateOptions{})
}</span>

// Eventf puts event into kubernetes events
func (c *ClientInfo) Eventf(object runtime.Object, eventtype, reason, messageFmt string, args ...interface{}) <span class="cov8" title="1">{
        if c != nil &amp;&amp; c.EventRecorder != nil </span><span class="cov0" title="0">{
                c.EventRecorder.Eventf(object, eventtype, reason, messageFmt, args...)
        }</span>
}

func (e *NoK8sNetworkError) Error() string <span class="cov8" title="1">{ return e.message }</span>

// SetNetworkStatus sets network status into Pod annotation
func SetNetworkStatus(client *ClientInfo, k8sArgs *types.K8sArgs, netStatus []nettypes.NetworkStatus, conf *types.NetConf) error <span class="cov8" title="1">{
        podName := string(k8sArgs.K8S_POD_NAME)
        podNamespace := string(k8sArgs.K8S_POD_NAMESPACE)
        podUID := string(k8sArgs.K8S_POD_UID)

        return SetPodNetworkStatusAnnotation(client, podName, podNamespace, podUID, netStatus, conf)
}</span>

// SetPodNetworkStatusAnnotation sets network status into Pod annotation
func SetPodNetworkStatusAnnotation(client *ClientInfo, podName string, podNamespace string, podUID string, netStatus []nettypes.NetworkStatus, conf *types.NetConf) error <span class="cov8" title="1">{
        var err error
        logging.Debugf("SetPodNetworkStatusAnnotation: %v, %v, %v", client, netStatus, conf)

        client, err = GetK8sClient(conf.Kubeconfig, client)
        if err != nil </span><span class="cov8" title="1">{
                return logging.Errorf("SetNetworkStatus: %v", err)
        }</span>
        <span class="cov8" title="1">if client == nil || client.Client == nil </span><span class="cov8" title="1">{
                if len(conf.Delegates) == 0 </span><span class="cov0" title="0">{
                        // No available kube client and no delegates, we can't do anything
                        return logging.Errorf("SetNetworkStatus: must have either Kubernetes config or delegates")
                }</span>
                <span class="cov8" title="1">logging.Debugf("SetPodNetworkStatusAnnotation: kube client info is not defined, skip network status setup")
                return nil</span>
        }

        <span class="cov8" title="1">pod, err := client.GetPod(podNamespace, podName)
        if err != nil </span><span class="cov0" title="0">{
                return logging.Errorf("SetPodNetworkStatusAnnotation: failed to query the pod %v in out of cluster comm: %v", podName, err)
        }</span>

        <span class="cov8" title="1">if podUID != "" &amp;&amp; string(pod.UID) != podUID &amp;&amp; !IsStaticPod(pod) </span><span class="cov8" title="1">{
                return logging.Errorf("SetNetworkStatus: expected pod %s/%s UID %q but got %q from Kube API", podNamespace, podName, podUID, pod.UID)
        }</span>

        <span class="cov8" title="1">if netStatus != nil </span><span class="cov8" title="1">{
                err = netutils.SetNetworkStatus(client.Client, pod, netStatus)
                if err != nil </span><span class="cov0" title="0">{
                        return logging.Errorf("SetPodNetworkStatusAnnotation: failed to update the pod %v in out of cluster comm: %v", podName, err)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func parsePodNetworkObjectName(podnetwork string) (string, string, string, error) <span class="cov8" title="1">{
        var netNsName string
        var netIfName string
        var networkName string

        logging.Debugf("parsePodNetworkObjectName: %s", podnetwork)
        slashItems := strings.Split(podnetwork, "/")
        if len(slashItems) == 2 </span><span class="cov8" title="1">{
                netNsName = strings.TrimSpace(slashItems[0])
                networkName = slashItems[1]
        }</span> else<span class="cov8" title="1"> if len(slashItems) == 1 </span><span class="cov8" title="1">{
                networkName = slashItems[0]
        }</span> else<span class="cov8" title="1"> {
                return "", "", "", logging.Errorf("parsePodNetworkObjectName: Invalid network object (failed at '/')")
        }</span>

        <span class="cov8" title="1">atItems := strings.Split(networkName, "@")
        networkName = strings.TrimSpace(atItems[0])
        if len(atItems) == 2 </span><span class="cov8" title="1">{
                netIfName = strings.TrimSpace(atItems[1])
        }</span> else<span class="cov8" title="1"> if len(atItems) != 1 </span><span class="cov8" title="1">{
                return "", "", "", logging.Errorf("parsePodNetworkObjectName: Invalid network object (failed at '@')")
        }</span>

        // Check and see if each item matches the specification for valid attachment name.
        // "Valid attachment names must be comprised of units of the DNS-1123 label format"
        // [a-z0-9]([-a-z0-9]*[a-z0-9])?
        // And we allow at (@), and forward slash (/) (units separated by commas)
        // It must start and end alphanumerically.
        <span class="cov8" title="1">allItems := []string{netNsName, networkName, netIfName}
        for i := range allItems </span><span class="cov8" title="1">{
                matched, _ := regexp.MatchString("^[a-z0-9]([-a-z0-9]*[a-z0-9])?$", allItems[i])
                if !matched &amp;&amp; len([]rune(allItems[i])) &gt; 0 </span><span class="cov8" title="1">{
                        return "", "", "", logging.Errorf(fmt.Sprintf("parsePodNetworkObjectName: Failed to parse: one or more items did not match comma-delimited format (must consist of lower case alphanumeric characters). Must start and end with an alphanumeric character), mismatch @ '%v'", allItems[i]))
                }</span>
        }

        <span class="cov8" title="1">logging.Debugf("parsePodNetworkObjectName: parsed: %s, %s, %s", netNsName, networkName, netIfName)
        return netNsName, networkName, netIfName, nil</span>
}

func parsePodNetworkAnnotation(podNetworks, defaultNamespace string) ([]*types.NetworkSelectionElement, error) <span class="cov8" title="1">{
        var networks []*types.NetworkSelectionElement

        logging.Debugf("parsePodNetworkAnnotation: %s, %s", podNetworks, defaultNamespace)
        if podNetworks == "" </span><span class="cov0" title="0">{
                return nil, logging.Errorf("parsePodNetworkAnnotation: pod annotation does not have \"network\" as key")
        }</span>

        <span class="cov8" title="1">if strings.IndexAny(podNetworks, "[{\"") &gt;= 0 </span><span class="cov8" title="1">{
                if err := json.Unmarshal([]byte(podNetworks), &amp;networks); err != nil </span><span class="cov8" title="1">{
                        return nil, logging.Errorf("parsePodNetworkAnnotation: failed to parse pod Network Attachment Selection Annotation JSON format: %v", err)
                }</span>
        } else<span class="cov8" title="1"> {
                // Comma-delimited list of network attachment object names
                for _, item := range strings.Split(podNetworks, ",") </span><span class="cov8" title="1">{
                        // Remove leading and trailing whitespace.
                        item = strings.TrimSpace(item)

                        // Parse network name (i.e. &lt;namespace&gt;/&lt;network name&gt;@&lt;ifname&gt;)
                        netNsName, networkName, netIfName, err := parsePodNetworkObjectName(item)
                        if err != nil </span><span class="cov8" title="1">{
                                return nil, logging.Errorf("parsePodNetworkAnnotation: %v", err)
                        }</span>

                        <span class="cov8" title="1">networks = append(networks, &amp;types.NetworkSelectionElement{
                                Name:             networkName,
                                Namespace:        netNsName,
                                InterfaceRequest: netIfName,
                        })</span>
                }
        }

        <span class="cov8" title="1">for _, n := range networks </span><span class="cov8" title="1">{
                if n.Namespace == "" </span><span class="cov8" title="1">{
                        n.Namespace = defaultNamespace
                }</span>
                <span class="cov8" title="1">if n.MacRequest != "" </span><span class="cov0" title="0">{
                        // validate MAC address
                        if _, err := net.ParseMAC(n.MacRequest); err != nil </span><span class="cov0" title="0">{
                                return nil, logging.Errorf("parsePodNetworkAnnotation: failed to mac: %v", err)
                        }</span>
                }
                <span class="cov8" title="1">if n.InfinibandGUIDRequest != "" </span><span class="cov0" title="0">{
                        // validate GUID address
                        if _, err := net.ParseMAC(n.InfinibandGUIDRequest); err != nil </span><span class="cov0" title="0">{
                                return nil, logging.Errorf("parsePodNetworkAnnotation: failed to validate infiniband GUID: %v", err)
                        }</span>
                }
                <span class="cov8" title="1">if n.IPRequest != nil </span><span class="cov0" title="0">{
                        for _, ip := range n.IPRequest </span><span class="cov0" title="0">{
                                // validate IP address
                                if strings.Contains(ip, "/") </span><span class="cov0" title="0">{
                                        if _, _, err := net.ParseCIDR(ip); err != nil </span><span class="cov0" title="0">{
                                                return nil, logging.Errorf("failed to parse CIDR %q: %v", ip, err)
                                        }</span>
                                } else<span class="cov0" title="0"> if net.ParseIP(ip) == nil </span><span class="cov0" title="0">{
                                        return nil, logging.Errorf("failed to parse IP address %q", ip)
                                }</span>
                        }
                }
                // compatibility pre v3.2, will be removed in v4.0
                <span class="cov8" title="1">if n.DeprecatedInterfaceRequest != "" &amp;&amp; n.InterfaceRequest == "" </span><span class="cov0" title="0">{
                        n.InterfaceRequest = n.DeprecatedInterfaceRequest
                }</span>
        }

        <span class="cov8" title="1">return networks, nil</span>
}

func getKubernetesDelegate(client *ClientInfo, net *types.NetworkSelectionElement, confdir string, pod *v1.Pod, resourceMap map[string]*types.ResourceInfo) (*types.DelegateNetConf, map[string]*types.ResourceInfo, error) <span class="cov8" title="1">{

        logging.Debugf("getKubernetesDelegate: %v, %v, %s, %v, %v", client, net, confdir, pod, resourceMap)
        customResource, err := client.NetClient.NetworkAttachmentDefinitions(net.Namespace).Get(context.TODO(), net.Name, metav1.GetOptions{})
        if err != nil </span><span class="cov8" title="1">{
                errMsg := fmt.Sprintf("cannot find a network-attachment-definition (%s) in namespace (%s): %v", net.Name, net.Namespace, err)
                if client != nil </span><span class="cov8" title="1">{
                        client.Eventf(pod, v1.EventTypeWarning, "NoNetworkFound", errMsg)
                }</span>
                <span class="cov8" title="1">return nil, resourceMap, logging.Errorf("getKubernetesDelegate: " + errMsg)</span>
        }

        // Get resourceName annotation from NetworkAttachmentDefinition
        <span class="cov8" title="1">deviceID := ""
        resourceName, ok := customResource.GetAnnotations()[resourceNameAnnot]
        if ok &amp;&amp; pod.Name != "" &amp;&amp; pod.Namespace != "" </span><span class="cov8" title="1">{
                // ResourceName annotation is found; try to get device info from resourceMap
                logging.Debugf("getKubernetesDelegate: found resourceName annotation : %s", resourceName)

                if resourceMap == nil </span><span class="cov8" title="1">{
                        ck, err := kubeletclient.GetResourceClient("")
                        if err != nil </span><span class="cov8" title="1">{
                                return nil, resourceMap, logging.Errorf("getKubernetesDelegate: failed to get a ResourceClient instance: %v", err)
                        }</span>
                        <span class="cov0" title="0">resourceMap, err = ck.GetPodResourceMap(pod)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, resourceMap, logging.Errorf("getKubernetesDelegate: failed to get resourceMap from ResourceClient: %v", err)
                        }</span>
                        <span class="cov0" title="0">logging.Debugf("getKubernetesDelegate: resourceMap instance: %+v", resourceMap)</span>
                }

                <span class="cov0" title="0">entry, ok := resourceMap[resourceName]
                if ok </span><span class="cov0" title="0">{
                        if idCount := len(entry.DeviceIDs); idCount &gt; 0 &amp;&amp; idCount &gt; entry.Index </span><span class="cov0" title="0">{
                                deviceID = entry.DeviceIDs[entry.Index]
                                logging.Debugf("getKubernetesDelegate: podName: %s deviceID: %s", pod.Name, deviceID)
                                entry.Index++ // increment Index for next delegate
                        }</span>
                }
        }

        <span class="cov8" title="1">configBytes, err := netutils.GetCNIConfig(customResource, confdir)
        if err != nil </span><span class="cov8" title="1">{
                return nil, resourceMap, err
        }</span>

        <span class="cov8" title="1">delegate, err := types.LoadDelegateNetConf(configBytes, net, deviceID, resourceName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, resourceMap, err
        }</span>

        <span class="cov8" title="1">return delegate, resourceMap, nil</span>
}

// GetK8sArgs gets k8s related args from CNI args
func GetK8sArgs(args *skel.CmdArgs) (*types.K8sArgs, error) <span class="cov8" title="1">{
        k8sArgs := &amp;types.K8sArgs{}

        logging.Debugf("GetK8sArgs: %v", args)
        err := cnitypes.LoadArgs(args.Args, k8sArgs)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return k8sArgs, nil</span>
}

// TryLoadPodDelegates attempts to load Kubernetes-defined delegates and add them to the Multus config.
// Returns the number of Kubernetes-defined delegates added or an error.
func TryLoadPodDelegates(pod *v1.Pod, conf *types.NetConf, clientInfo *ClientInfo, resourceMap map[string]*types.ResourceInfo) (int, *ClientInfo, error) <span class="cov8" title="1">{
        var err error

        logging.Debugf("TryLoadPodDelegates: %v, %v, %v", pod, conf, clientInfo)
        clientInfo, err = GetK8sClient(conf.Kubeconfig, clientInfo)
        if err != nil </span><span class="cov8" title="1">{
                return 0, nil, err
        }</span>

        <span class="cov8" title="1">if clientInfo == nil </span><span class="cov8" title="1">{
                if len(conf.Delegates) == 0 </span><span class="cov8" title="1">{
                        // No available kube client and no delegates, we can't do anything
                        return 0, nil, logging.Errorf("TryLoadPodDelegates: must have either Kubernetes config or delegates")
                }</span>
                <span class="cov8" title="1">return 0, nil, nil</span>
        }

        <span class="cov8" title="1">delegate, err := tryLoadK8sPodDefaultNetwork(clientInfo, pod, conf)
        if err != nil </span><span class="cov8" title="1">{
                return 0, nil, logging.Errorf("TryLoadPodDelegates: error in loading K8s cluster default network from pod annotation: %v", err)
        }</span>
        <span class="cov8" title="1">if delegate != nil </span><span class="cov8" title="1">{
                logging.Debugf("TryLoadPodDelegates: Overwrite the cluster default network with %v from pod annotations", delegate)

                conf.Delegates[0] = delegate
        }</span>

        <span class="cov8" title="1">networks, err := GetPodNetwork(pod)
        if networks != nil </span><span class="cov0" title="0">{
                delegates, err := GetNetworkDelegates(clientInfo, pod, networks, conf, resourceMap)

                if err != nil </span><span class="cov0" title="0">{
                        if _, ok := err.(*NoK8sNetworkError); ok </span><span class="cov0" title="0">{
                                return 0, clientInfo, nil
                        }</span>
                        <span class="cov0" title="0">return 0, nil, logging.Errorf("TryLoadPodDelegates: error in getting k8s network for pod: %v", err)</span>
                }

                <span class="cov0" title="0">if err = conf.AddDelegates(delegates); err != nil </span><span class="cov0" title="0">{
                        return 0, nil, err
                }</span>

                // Check gatewayRequest is configured in delegates
                // and mark its config if gateway filter is required
                <span class="cov0" title="0">isGatewayConfigured := false
                for _, delegate := range conf.Delegates </span><span class="cov0" title="0">{
                        if delegate.GatewayRequest != nil </span><span class="cov0" title="0">{
                                isGatewayConfigured = true
                                break</span>
                        }
                }

                <span class="cov0" title="0">if isGatewayConfigured == true </span><span class="cov0" title="0">{
                        err = types.CheckGatewayConfig(conf.Delegates)
                        if err != nil </span><span class="cov0" title="0">{
                                return 0, nil, err
                        }</span>
                }

                <span class="cov0" title="0">return len(delegates), clientInfo, err</span>
        }

        <span class="cov8" title="1">if _, ok := err.(*NoK8sNetworkError); ok </span><span class="cov8" title="1">{
                return 0, clientInfo, nil
        }</span>
        <span class="cov0" title="0">return 0, clientInfo, err</span>
}

// InClusterK8sClient returns the `k8s.ClientInfo` struct to use to connect to
// the k8s API.
func InClusterK8sClient() (*ClientInfo, error) <span class="cov0" title="0">{
        config, err := rest.InClusterConfig()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">logging.Debugf("InClusterK8sClient: in cluster config: %+v", config)
        return NewClientInfo(config)</span>
}

// GetK8sClient gets client info from kubeconfig
func GetK8sClient(kubeconfig string, kubeClient *ClientInfo) (*ClientInfo, error) <span class="cov8" title="1">{
        logging.Debugf("GetK8sClient: %s, %v", kubeconfig, kubeClient)
        // If we get a valid kubeClient (eg from testcases) just return that
        // one.
        if kubeClient != nil </span><span class="cov8" title="1">{
                return kubeClient, nil
        }</span>

        <span class="cov8" title="1">var err error
        var config *rest.Config

        // Otherwise try to create a kubeClient from a given kubeConfig
        if kubeconfig != "" </span><span class="cov8" title="1">{
                // uses the current context in kubeconfig
                config, err = clientcmd.BuildConfigFromFlags("", kubeconfig)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, logging.Errorf("GetK8sClient: failed to get context for the kubeconfig %v: %v", kubeconfig, err)
                }</span>
        } else<span class="cov8" title="1"> if os.Getenv("KUBERNETES_SERVICE_HOST") != "" &amp;&amp; os.Getenv("KUBERNETES_SERVICE_PORT") != "" </span><span class="cov0" title="0">{
                // Try in-cluster config where multus might be running in a kubernetes pod
                config, err = rest.InClusterConfig()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, logging.Errorf("GetK8sClient: failed to get context for in-cluster kube config: %v", err)
                }</span>
        } else<span class="cov8" title="1"> {
                // No kubernetes config; assume we shouldn't talk to Kube at all
                return nil, nil
        }</span>

        // Specify that we use gRPC
        <span class="cov0" title="0">config.AcceptContentTypes = "application/vnd.kubernetes.protobuf,application/json"
        config.ContentType = "application/vnd.kubernetes.protobuf"
        // Set the config timeout to one minute.
        config.Timeout = time.Minute

        return NewClientInfo(config)</span>
}

// NewClientInfo returns a `ClientInfo` from a configuration created from an
// existing kubeconfig file.
func NewClientInfo(config *rest.Config) (*ClientInfo, error) <span class="cov0" title="0">{
        client, err := kubernetes.NewForConfig(config)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">netclient, err := netclient.NewForConfig(config)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">broadcaster := record.NewBroadcaster()
        broadcaster.StartLogging(klog.Infof)
        broadcaster.StartRecordingToSink(&amp;v1core.EventSinkImpl{Interface: client.CoreV1().Events("")})
        recorder := broadcaster.NewRecorder(scheme.Scheme, v1.EventSource{Component: "multus"})
        return &amp;ClientInfo{
                Client:           client,
                NetClient:        netclient,
                EventBroadcaster: broadcaster,
                EventRecorder:    recorder,
        }, nil</span>
}

// GetPodNetwork gets net-attach-def annotation from pod
func GetPodNetwork(pod *v1.Pod) ([]*types.NetworkSelectionElement, error) <span class="cov8" title="1">{
        logging.Debugf("GetPodNetwork: %v", pod)

        netAnnot := pod.Annotations[networkAttachmentAnnot]
        defaultNamespace := pod.ObjectMeta.Namespace

        if len(netAnnot) == 0 </span><span class="cov8" title="1">{
                return nil, &amp;NoK8sNetworkError{"no kubernetes network found"}
        }</span>

        <span class="cov8" title="1">networks, err := parsePodNetworkAnnotation(netAnnot, defaultNamespace)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return networks, nil</span>
}

// GetNetworkDelegates returns delegatenetconf from net-attach-def annotation in pod
func GetNetworkDelegates(k8sclient *ClientInfo, pod *v1.Pod, networks []*types.NetworkSelectionElement, conf *types.NetConf, resourceMap map[string]*types.ResourceInfo) ([]*types.DelegateNetConf, error) <span class="cov8" title="1">{
        logging.Debugf("GetNetworkDelegates: %v, %v, %v, %v, %v", k8sclient, pod, networks, conf, resourceMap)

        // Read all network objects referenced by 'networks'
        var delegates []*types.DelegateNetConf
        defaultNamespace := pod.ObjectMeta.Namespace

        for _, net := range networks </span><span class="cov8" title="1">{

                // The pods namespace (stored as defaultNamespace, does not equal the annotation's target namespace in net.Namespace)
                // In the case that this is a mismatch when namespaceisolation is enabled, this should be an error.
                if conf.NamespaceIsolation </span><span class="cov8" title="1">{
                        if defaultNamespace != net.Namespace </span><span class="cov8" title="1">{
                                // We allow exceptions based on the specified list of non-isolated namespaces (and/or "default" namespace, by default)
                                if !isValidNamespaceReference(net.Namespace, conf.NonIsolatedNamespaces) </span><span class="cov8" title="1">{
                                        return nil, logging.Errorf("GetNetworkDelegates: namespace isolation enabled, annotation violates permission, pod is in namespace %v but refers to target namespace %v", defaultNamespace, net.Namespace)
                                }</span>
                        }
                }

                <span class="cov8" title="1">delegate, updatedResourceMap, err := getKubernetesDelegate(k8sclient, net, conf.ConfDir, pod, resourceMap)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, logging.Errorf("GetNetworkDelegates: failed getting the delegate: %v", err)
                }</span>
                <span class="cov8" title="1">delegates = append(delegates, delegate)
                resourceMap = updatedResourceMap</span>
        }

        <span class="cov8" title="1">return delegates, nil</span>
}

func isValidNamespaceReference(targetns string, allowednamespaces []string) bool <span class="cov8" title="1">{
        for _, eachns := range allowednamespaces </span><span class="cov8" title="1">{
                if eachns == targetns </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// getNetDelegate loads delegate network for clusterNetwork/defaultNetworks
func getNetDelegate(client *ClientInfo, pod *v1.Pod, netname, confdir, namespace string, resourceMap map[string]*types.ResourceInfo) (*types.DelegateNetConf, map[string]*types.ResourceInfo, error) <span class="cov8" title="1">{
        logging.Debugf("getNetDelegate: %v, %v, %v, %s", client, netname, confdir, namespace)
        var configBytes []byte
        isNetnamePath := strings.Contains(netname, "/")

        // if netname is not directory or file, it must be net-attach-def name or CNI config name
        if !isNetnamePath </span><span class="cov8" title="1">{
                // option1) search CRD object for the network
                net := &amp;types.NetworkSelectionElement{
                        Name:      netname,
                        Namespace: namespace,
                }
                delegate, resourceMap, err := getKubernetesDelegate(client, net, confdir, pod, resourceMap)
                if err == nil </span><span class="cov8" title="1">{
                        return delegate, resourceMap, nil
                }</span>

                // option2) search CNI json config file, which has &lt;netname&gt; as CNI name, from confDir
                <span class="cov8" title="1">configBytes, err = netutils.GetCNIConfigFromFile(netname, confdir)
                if err == nil </span><span class="cov8" title="1">{
                        delegate, err := types.LoadDelegateNetConf(configBytes, nil, "", "")
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, resourceMap, err
                        }</span>
                        <span class="cov8" title="1">return delegate, resourceMap, nil</span>
                }
        } else<span class="cov8" title="1"> {
                fInfo, err := os.Stat(netname)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, resourceMap, err
                }</span>

                // option3) search directory
                <span class="cov8" title="1">if fInfo.IsDir() </span><span class="cov8" title="1">{
                        files, err := libcni.ConfFiles(netname, []string{".conf", ".conflist"})
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, resourceMap, err
                        }</span>
                        <span class="cov8" title="1">if len(files) &gt; 0 </span><span class="cov8" title="1">{
                                var configBytes []byte
                                configBytes, err = netutils.GetCNIConfigFromFile("", netname)
                                if err == nil </span><span class="cov8" title="1">{
                                        delegate, err := types.LoadDelegateNetConf(configBytes, nil, "", "")
                                        if err != nil </span><span class="cov0" title="0">{
                                                return nil, resourceMap, err
                                        }</span>
                                        <span class="cov8" title="1">return delegate, resourceMap, nil</span>
                                }
                                <span class="cov0" title="0">return nil, resourceMap, err</span>
                        }
                } else<span class="cov8" title="1"> {
                        // option4) if file path (absolute), then load it directly
                        if strings.HasSuffix(netname, ".conflist") </span><span class="cov0" title="0">{
                                confList, err := libcni.ConfListFromFile(netname)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, resourceMap, logging.Errorf("error loading CNI conflist file %s: %v", netname, err)
                                }</span>
                                <span class="cov0" title="0">configBytes = confList.Bytes</span>
                        } else<span class="cov8" title="1"> {
                                conf, err := libcni.ConfFromFile(netname)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, resourceMap, logging.Errorf("error loading CNI config file %s: %v", netname, err)
                                }</span>
                                <span class="cov8" title="1">if conf.Network.Type == "" </span><span class="cov0" title="0">{
                                        return nil, resourceMap, logging.Errorf("error loading CNI config file %s: no 'type'; perhaps this is a .conflist?", netname)
                                }</span>
                                <span class="cov8" title="1">configBytes = conf.Bytes</span>
                        }
                        <span class="cov8" title="1">delegate, err := types.LoadDelegateNetConf(configBytes, nil, "", "")
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, resourceMap, err
                        }</span>
                        <span class="cov8" title="1">return delegate, resourceMap, nil</span>
                }
        }
        <span class="cov8" title="1">return nil, resourceMap, logging.Errorf("getNetDelegate: cannot find network: %v", netname)</span>
}

// GetDefaultNetworks parses 'defaultNetwork' config, gets network json and put it into netconf.Delegates.
func GetDefaultNetworks(pod *v1.Pod, conf *types.NetConf, kubeClient *ClientInfo, resourceMap map[string]*types.ResourceInfo) (map[string]*types.ResourceInfo, error) <span class="cov8" title="1">{
        logging.Debugf("GetDefaultNetworks: %v, %v, %v, %v", pod, conf, kubeClient, resourceMap)
        var delegates []*types.DelegateNetConf

        kubeClient, err := GetK8sClient(conf.Kubeconfig, kubeClient)
        if err != nil </span><span class="cov0" title="0">{
                return resourceMap, err
        }</span>
        <span class="cov8" title="1">if kubeClient == nil </span><span class="cov0" title="0">{
                if len(conf.Delegates) == 0 </span><span class="cov0" title="0">{
                        // No available kube client and no delegates, we can't do anything
                        return resourceMap, logging.Errorf("GetDefaultNetworks: must have either Kubernetes config or delegates")
                }</span>
                <span class="cov0" title="0">return resourceMap, nil</span>
        }

        <span class="cov8" title="1">delegate, resourceMap, err := getNetDelegate(kubeClient, pod, conf.ClusterNetwork, conf.ConfDir, conf.MultusNamespace, resourceMap)

        if err != nil </span><span class="cov8" title="1">{
                return resourceMap, logging.Errorf("GetDefaultNetworks: failed to get clusterNetwork %s in namespace %s", conf.ClusterNetwork, conf.MultusNamespace)
        }</span>
        <span class="cov8" title="1">delegate.MasterPlugin = true
        delegates = append(delegates, delegate)

        // Pod in kube-system namespace does not have default network for now.
        if !types.CheckSystemNamespaces(pod.ObjectMeta.Namespace, conf.SystemNamespaces) </span><span class="cov8" title="1">{
                for _, netname := range conf.DefaultNetworks </span><span class="cov8" title="1">{
                        delegate, resourceMap, err := getNetDelegate(kubeClient, pod, netname, conf.ConfDir, conf.MultusNamespace, resourceMap)
                        if err != nil </span><span class="cov0" title="0">{
                                return resourceMap, err
                        }</span>
                        <span class="cov8" title="1">delegates = append(delegates, delegate)</span>
                }
        }

        <span class="cov8" title="1">if err = conf.AddDelegates(delegates); err != nil </span><span class="cov0" title="0">{
                return resourceMap, err
        }</span>

        <span class="cov8" title="1">return resourceMap, nil</span>
}

// tryLoadK8sPodDefaultNetwork get pod default network from annotations
func tryLoadK8sPodDefaultNetwork(kubeClient *ClientInfo, pod *v1.Pod, conf *types.NetConf) (*types.DelegateNetConf, error) <span class="cov8" title="1">{
        var netAnnot string
        logging.Debugf("tryLoadK8sPodDefaultNetwork: %v, %v, %v", kubeClient, pod, conf)

        netAnnot, ok := pod.Annotations[defaultNetAnnot]
        if !ok </span><span class="cov0" title="0">{
                logging.Debugf("tryLoadK8sPodDefaultNetwork: Pod default network annotation is not defined")
                return nil, nil
        }</span>

        // The CRD object of default network should only be defined in multusNamespace
        <span class="cov8" title="1">networks, err := parsePodNetworkAnnotation(netAnnot, conf.MultusNamespace)
        if err != nil </span><span class="cov0" title="0">{
                return nil, logging.Errorf("tryLoadK8sPodDefaultNetwork: failed to parse CRD object: %v", err)
        }</span>
        <span class="cov8" title="1">if len(networks) &gt; 1 </span><span class="cov0" title="0">{
                return nil, logging.Errorf("tryLoadK8sPodDefaultNetwork: more than one default network is specified: %s", netAnnot)
        }</span>

        <span class="cov8" title="1">delegate, _, err := getKubernetesDelegate(kubeClient, networks[0], conf.ConfDir, pod, nil)
        if err != nil </span><span class="cov8" title="1">{
                return nil, logging.Errorf("tryLoadK8sPodDefaultNetwork: failed getting the delegate: %v", err)
        }</span>
        <span class="cov8" title="1">delegate.MasterPlugin = true

        return delegate, nil</span>
}

// ConfigSourceAnnotationKey specifies kubernetes annotation, defined in k8s.io/kubernetes/pkg/kubelet/types
const ConfigSourceAnnotationKey = "kubernetes.io/config.source"

// IsStaticPod returns true if the pod is static pod.
func IsStaticPod(pod *v1.Pod) bool <span class="cov8" title="1">{
        if pod.Annotations != nil </span><span class="cov8" title="1">{
                if source, ok := pod.Annotations[ConfigSourceAnnotationKey]; ok == true </span><span class="cov0" title="0">{
                        return source != "api"
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package kubeletclient

import (
        "fmt"
        "net"
        "net/url"
        "os"
        "path/filepath"
        "time"

        "golang.org/x/net/context"
        "google.golang.org/grpc"

        "gopkg.in/k8snetworkplumbingwg/multus-cni.v3/pkg/checkpoint"
        "gopkg.in/k8snetworkplumbingwg/multus-cni.v3/pkg/logging"
        "gopkg.in/k8snetworkplumbingwg/multus-cni.v3/pkg/types"
        v1 "k8s.io/api/core/v1"
        podresourcesapi "k8s.io/kubelet/pkg/apis/podresources/v1"
)

const (
        kubeletSocket              = "kubelet" // which is defined in k8s.io/kubernetes/pkg/kubelet/apis/podresources
        kubeletConnectionTimeout   = 10 * time.Second
        defaultKubeletSocketFile   = "kubelet.sock"
        defaultPodResourcesMaxSize = 1024 * 1024 * 16 // 16 Mb
        defaultPodResourcesPath    = "/var/lib/kubelet/pod-resources"
        unixProtocol               = "unix"
)

// LocalEndpoint returns the full path to a unix socket at the given endpoint
// which is in k8s.io/kubernetes/pkg/kubelet/util
func LocalEndpoint(path, file string) (string, error) <span class="cov0" title="0">{
        u := url.URL{
                Scheme: unixProtocol,
                Path:   path,
        }
        return filepath.Join(u.String(), file+".sock"), nil
}</span>

// GetResourceClient returns an instance of ResourceClient interface initialized with Pod resource information
func GetResourceClient(kubeletSocket string) (types.ResourceClient, error) <span class="cov8" title="1">{
        if kubeletSocket == "" </span><span class="cov0" title="0">{
                kubeletSocket, _ = LocalEndpoint(defaultPodResourcesPath, kubeletSocket)
        }</span>
        // If Kubelet resource API endpoint exist use that by default
        // Or else fallback with checkpoint file
        <span class="cov8" title="1">if hasKubeletAPIEndpoint(kubeletSocket) </span><span class="cov8" title="1">{
                logging.Debugf("GetResourceClient: using Kubelet resource API endpoint")
                return getKubeletClient(kubeletSocket)
        }</span>

        <span class="cov8" title="1">logging.Debugf("GetResourceClient: using Kubelet device plugin checkpoint")
        return checkpoint.GetCheckpoint()</span>
}

func dial(ctx context.Context, addr string) (net.Conn, error) <span class="cov8" title="1">{
        return (&amp;net.Dialer{}).DialContext(ctx, unixProtocol, addr)
}</span>

func getKubeletResourceClient(kubeletSocket string, timeout time.Duration) (podresourcesapi.PodResourcesListerClient, *grpc.ClientConn, error) <span class="cov8" title="1">{
        ctx, cancel := context.WithTimeout(context.Background(), timeout)
        defer cancel()

        conn, err := grpc.DialContext(ctx, kubeletSocket, grpc.WithInsecure(),
                grpc.WithContextDialer(dial),
                grpc.WithDefaultCallOptions(grpc.MaxCallRecvMsgSize(defaultPodResourcesMaxSize)))
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("error dialing socket %s: %v", kubeletSocket, err)
        }</span>
        <span class="cov8" title="1">return podresourcesapi.NewPodResourcesListerClient(conn), conn, nil</span>
}

func getKubeletClient(kubeletSocket string) (types.ResourceClient, error) <span class="cov8" title="1">{
        newClient := &amp;kubeletClient{}
        if kubeletSocket == "" </span><span class="cov0" title="0">{
                kubeletSocket, _ = LocalEndpoint(defaultPodResourcesPath, kubeletSocket)
        }</span>

        <span class="cov8" title="1">client, conn, err := getKubeletResourceClient(kubeletSocket, 10*time.Second)
        if err != nil </span><span class="cov0" title="0">{
                return nil, logging.Errorf("getKubeletClient: error getting grpc client: %v\n", err)
        }</span>
        <span class="cov8" title="1">defer conn.Close()

        if err := newClient.getPodResources(client); err != nil </span><span class="cov8" title="1">{
                return nil, logging.Errorf("getKubeletClient: error getting pod resources from client: %v\n", err)
        }</span>

        <span class="cov8" title="1">return newClient, nil</span>
}

type kubeletClient struct {
        resources []*podresourcesapi.PodResources
}

func (rc *kubeletClient) getPodResources(client podresourcesapi.PodResourcesListerClient) error <span class="cov8" title="1">{

        ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
        defer cancel()

        resp, err := client.List(ctx, &amp;podresourcesapi.ListPodResourcesRequest{})
        if err != nil </span><span class="cov8" title="1">{
                return logging.Errorf("getPodResources: failed to list pod resources, %v.Get(_) = _, %v", client, err)
        }</span>

        <span class="cov8" title="1">rc.resources = resp.PodResources
        return nil</span>
}

// GetPodResourceMap returns an instance of a map of Pod ResourceInfo given a (Pod name, namespace) tuple
func (rc *kubeletClient) GetPodResourceMap(pod *v1.Pod) (map[string]*types.ResourceInfo, error) <span class="cov8" title="1">{
        resourceMap := make(map[string]*types.ResourceInfo)

        name := pod.Name
        ns := pod.Namespace

        if name == "" || ns == "" </span><span class="cov8" title="1">{
                return nil, logging.Errorf("GetPodResourcesMap: Pod name or namespace cannot be empty")
        }</span>

        <span class="cov8" title="1">for _, pr := range rc.resources </span><span class="cov8" title="1">{
                if pr.Name == name &amp;&amp; pr.Namespace == ns </span><span class="cov8" title="1">{
                        for _, cnt := range pr.Containers </span><span class="cov8" title="1">{
                                for _, dev := range cnt.Devices </span><span class="cov8" title="1">{
                                        if rInfo, ok := resourceMap[dev.ResourceName]; ok </span><span class="cov0" title="0">{
                                                rInfo.DeviceIDs = append(rInfo.DeviceIDs, dev.DeviceIds...)
                                        }</span> else<span class="cov8" title="1"> {
                                                resourceMap[dev.ResourceName] = &amp;types.ResourceInfo{DeviceIDs: dev.DeviceIds}
                                        }</span>
                                }
                        }
                }
        }
        <span class="cov8" title="1">return resourceMap, nil</span>
}

func hasKubeletAPIEndpoint(endpoint string) bool <span class="cov8" title="1">{
        u, err := url.Parse(endpoint)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        // Check for kubelet resource API socket file
        <span class="cov8" title="1">if _, err := os.Stat(u.Path); err != nil </span><span class="cov8" title="1">{
                logging.Debugf("hasKubeletAPIEndpoint: error looking up kubelet resource api socket file: %q", err)
                return false
        }</span>
        <span class="cov8" title="1">return true</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">// Copyright (c) 2018 Intel Corporation
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package logging

import (
        "fmt"
        "io"
        "os"
        "strings"
        "time"

        "github.com/pkg/errors"
        lumberjack "gopkg.in/natefinch/lumberjack.v2"
)

// Level type
type Level uint32

// PanicLevel...MaxLevel indicates the logging level
const (
        PanicLevel Level = iota
        ErrorLevel
        VerboseLevel
        DebugLevel
        MaxLevel
        UnknownLevel
)

var loggingStderr bool
var loggingW io.Writer
var loggingLevel Level
var logger *lumberjack.Logger

const defaultTimestampFormat = time.RFC3339

// LogOptions specifies the configuration of the log
type LogOptions struct {
        MaxAge     *int  `json:"maxAge,omitempty"`
        MaxSize    *int  `json:"maxSize,omitempty"`
        MaxBackups *int  `json:"maxBackups,omitempty"`
        Compress   *bool `json:"compress,omitempty"`
}

// SetLogOptions set the LoggingOptions of NetConf
func SetLogOptions(options *LogOptions) <span class="cov8" title="1">{
        // give some default value
        logger.MaxSize = 100
        logger.MaxAge = 5
        logger.MaxBackups = 5
        logger.Compress = true
        if options != nil </span><span class="cov8" title="1">{
                if options.MaxAge != nil </span><span class="cov8" title="1">{
                        logger.MaxAge = *options.MaxAge
                }</span>
                <span class="cov8" title="1">if options.MaxSize != nil </span><span class="cov8" title="1">{
                        logger.MaxSize = *options.MaxSize
                }</span>
                <span class="cov8" title="1">if options.MaxBackups != nil </span><span class="cov8" title="1">{
                        logger.MaxBackups = *options.MaxBackups
                }</span>
                <span class="cov8" title="1">if options.Compress != nil </span><span class="cov8" title="1">{
                        logger.Compress = *options.Compress
                }</span>
        }
        <span class="cov8" title="1">loggingW = logger</span>
}

func (l Level) String() string <span class="cov8" title="1">{
        switch l </span>{
        case PanicLevel:<span class="cov8" title="1">
                return "panic"</span>
        case VerboseLevel:<span class="cov8" title="1">
                return "verbose"</span>
        case ErrorLevel:<span class="cov8" title="1">
                return "error"</span>
        case DebugLevel:<span class="cov8" title="1">
                return "debug"</span>
        }
        <span class="cov0" title="0">return "unknown"</span>
}

func printf(level Level, format string, a ...interface{}) <span class="cov8" title="1">{
        header := "%s [%s] "
        t := time.Now()
        if level &gt; loggingLevel </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">if loggingStderr </span><span class="cov8" title="1">{
                fmt.Fprintf(os.Stderr, header, t.Format(defaultTimestampFormat), level)
                fmt.Fprintf(os.Stderr, format, a...)
                fmt.Fprintf(os.Stderr, "\n")
        }</span>

        <span class="cov8" title="1">if loggingW != nil </span><span class="cov8" title="1">{
                fmt.Fprintf(loggingW, header, t.Format(defaultTimestampFormat), level)
                fmt.Fprintf(loggingW, format, a...)
                fmt.Fprintf(loggingW, "\n")
        }</span>
}

// Debugf prints logging if logging level &gt;= debug
func Debugf(format string, a ...interface{}) <span class="cov8" title="1">{
        printf(DebugLevel, format, a...)
}</span>

// Verbosef prints logging if logging level &gt;= verbose
func Verbosef(format string, a ...interface{}) <span class="cov8" title="1">{
        printf(VerboseLevel, format, a...)
}</span>

// Errorf prints logging if logging level &gt;= error
func Errorf(format string, a ...interface{}) error <span class="cov8" title="1">{
        printf(ErrorLevel, format, a...)
        return fmt.Errorf(format, a...)
}</span>

// Panicf prints logging plus stack trace. This should be used only for unrecoverable error
func Panicf(format string, a ...interface{}) <span class="cov8" title="1">{
        printf(PanicLevel, format, a...)
        printf(PanicLevel, "========= Stack trace output ========")
        printf(PanicLevel, "%+v", errors.New("Multus Panic"))
        printf(PanicLevel, "========= Stack trace output end ========")
}</span>

// GetLoggingLevel gets current logging level
func GetLoggingLevel() Level <span class="cov8" title="1">{
        return loggingLevel
}</span>

func getLoggingLevel(levelStr string) Level <span class="cov8" title="1">{
        switch strings.ToLower(levelStr) </span>{
        case "debug":<span class="cov8" title="1">
                return DebugLevel</span>
        case "verbose":<span class="cov8" title="1">
                return VerboseLevel</span>
        case "error":<span class="cov8" title="1">
                return ErrorLevel</span>
        case "panic":<span class="cov8" title="1">
                return PanicLevel</span>
        }
        <span class="cov8" title="1">fmt.Fprintf(os.Stderr, "multus logging: cannot set logging level to %s\n", levelStr)
        return UnknownLevel</span>
}

// SetLogLevel sets logging level
func SetLogLevel(levelStr string) <span class="cov8" title="1">{
        level := getLoggingLevel(levelStr)
        if level &lt; MaxLevel </span><span class="cov8" title="1">{
                loggingLevel = level
        }</span>
}

// SetLogStderr sets flag for logging stderr output
func SetLogStderr(enable bool) <span class="cov8" title="1">{
        loggingStderr = enable
}</span>

// SetLogFile sets logging file
func SetLogFile(filename string) <span class="cov8" title="1">{
        if filename == "" </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">logger.Filename = filename
        loggingW = logger</span>

}

func init() <span class="cov8" title="1">{
        loggingStderr = true
        loggingW = nil
        loggingLevel = PanicLevel
        logger = &amp;lumberjack.Logger{}
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">// Copyright (c) 2017 Intel Corporation
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package multus

import (
        "context"
        "encoding/json"
        "fmt"
        "io/ioutil"
        "net"
        "os"
        "path/filepath"
        "strings"
        "time"

        "github.com/containernetworking/cni/libcni"
        "github.com/containernetworking/cni/pkg/invoke"
        "github.com/containernetworking/cni/pkg/skel"
        cnitypes "github.com/containernetworking/cni/pkg/types"
        cni100 "github.com/containernetworking/cni/pkg/types/100"
        "github.com/containernetworking/plugins/pkg/ns"
        nettypes "github.com/k8snetworkplumbingwg/network-attachment-definition-client/pkg/apis/k8s.cni.cncf.io/v1"
        nadutils "github.com/k8snetworkplumbingwg/network-attachment-definition-client/pkg/utils"
        "github.com/vishvananda/netlink"
        k8s "gopkg.in/k8snetworkplumbingwg/multus-cni.v3/pkg/k8sclient"
        "gopkg.in/k8snetworkplumbingwg/multus-cni.v3/pkg/logging"
        "gopkg.in/k8snetworkplumbingwg/multus-cni.v3/pkg/netutils"
        "gopkg.in/k8snetworkplumbingwg/multus-cni.v3/pkg/types"
        v1 "k8s.io/api/core/v1"
        "k8s.io/apimachinery/pkg/api/errors"
        k8snet "k8s.io/apimachinery/pkg/util/net"
        "k8s.io/apimachinery/pkg/util/wait"
)

const (
        shortPollDuration = 250 * time.Millisecond
        shortPollTimeout  = 2500 * time.Millisecond
)

var (
        version = "master@git"
        commit  = "unknown commit"
        date    = "unknown date"
)

var (
        pollDuration = 1000 * time.Millisecond
        pollTimeout  = 45 * time.Second
)

//PrintVersionString ...
func PrintVersionString() string <span class="cov0" title="0">{
        return fmt.Sprintf("multus-cni version:%s, commit:%s, date:%s",
                version, commit, date)
}</span>

func saveScratchNetConf(containerID, dataDir string, netconf []byte) error <span class="cov8" title="1">{
        logging.Debugf("saveScratchNetConf: %s, %s, %s", containerID, dataDir, string(netconf))
        if err := os.MkdirAll(dataDir, 0700); err != nil </span><span class="cov8" title="1">{
                return logging.Errorf("saveScratchNetConf: failed to create the multus data directory(%q): %v", dataDir, err)
        }</span>

        <span class="cov8" title="1">path := filepath.Join(dataDir, containerID)

        err := ioutil.WriteFile(path, netconf, 0600)
        if err != nil </span><span class="cov0" title="0">{
                return logging.Errorf("saveScratchNetConf: failed to write container data in the path(%q): %v", path, err)
        }</span>

        <span class="cov8" title="1">return err</span>
}

func consumeScratchNetConf(containerID, dataDir string) ([]byte, string, error) <span class="cov8" title="1">{
        logging.Debugf("consumeScratchNetConf: %s, %s", containerID, dataDir)
        path := filepath.Join(dataDir, containerID)

        b, err := ioutil.ReadFile(path)
        return b, path, err
}</span>

func getIfname(delegate *types.DelegateNetConf, argif string, idx int) string <span class="cov8" title="1">{
        logging.Debugf("getIfname: %v, %s, %d", delegate, argif, idx)
        if delegate.IfnameRequest != "" </span><span class="cov0" title="0">{
                return delegate.IfnameRequest
        }</span>
        <span class="cov8" title="1">if delegate.MasterPlugin </span><span class="cov8" title="1">{
                // master plugin always uses the CNI-provided interface name
                return argif
        }</span>

        // Otherwise construct a unique interface name from the delegate's
        // position in the delegate list
        <span class="cov8" title="1">return fmt.Sprintf("net%d", idx)</span>
}

func getDelegateDeviceInfo(delegate *types.DelegateNetConf, runtimeConf *libcni.RuntimeConf) (*nettypes.DeviceInfo, error) <span class="cov8" title="1">{
        // If the DPDeviceInfoFile was created, it was copied to the CNIDeviceInfoFile.
        // If the DPDeviceInfoFile was not created, CNI might have created it. So
        // either way, load CNIDeviceInfoFile.
        if info, ok := runtimeConf.CapabilityArgs["CNIDeviceInfoFile"]; ok </span><span class="cov0" title="0">{
                if infostr, ok := info.(string); ok </span><span class="cov0" title="0">{
                        return nadutils.LoadDeviceInfoFromCNI(infostr)
                }</span>
        } else<span class="cov8" title="1"> {
                logging.Debugf("getDelegateDeviceInfo(): No CapArgs - info=%v ok=%v", info, ok)
        }</span>
        <span class="cov8" title="1">return nil, nil</span>
}

func saveDelegates(containerID, dataDir string, delegates []*types.DelegateNetConf) error <span class="cov8" title="1">{
        logging.Debugf("saveDelegates: %s, %s, %v", containerID, dataDir, delegates)
        delegatesBytes, err := json.Marshal(delegates)
        if err != nil </span><span class="cov0" title="0">{
                return logging.Errorf("saveDelegates: error serializing delegate netconf: %v", err)
        }</span>

        <span class="cov8" title="1">if err = saveScratchNetConf(containerID, dataDir, delegatesBytes); err != nil </span><span class="cov0" title="0">{
                return logging.Errorf("saveDelegates: error in saving the delegates : %v", err)
        }</span>

        <span class="cov8" title="1">return err</span>
}

func deleteDelegates(containerID, dataDir string) error <span class="cov8" title="1">{
        logging.Debugf("deleteDelegates: %s, %s", containerID, dataDir)

        path := filepath.Join(dataDir, containerID)
        if err := os.Remove(path); err != nil </span><span class="cov8" title="1">{
                return logging.Errorf("deleteDelegates: error in deleting the delegates : %v", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func validateIfName(nsname string, ifname string) error <span class="cov8" title="1">{
        logging.Debugf("validateIfName: %s, %s", nsname, ifname)
        podNs, err := ns.GetNS(nsname)
        if err != nil </span><span class="cov8" title="1">{
                return logging.Errorf("validateIfName: no net namespace %s found: %v", nsname, err)
        }</span>

        <span class="cov8" title="1">err = podNs.Do(func(_ ns.NetNS) error </span><span class="cov8" title="1">{
                _, err := netlink.LinkByName(ifname)
                if err != nil </span><span class="cov8" title="1">{
                        if err.Error() == "Link not found" </span><span class="cov8" title="1">{
                                return nil
                        }</span>
                        <span class="cov0" title="0">return err</span>
                }
                <span class="cov0" title="0">return logging.Errorf("validateIfName: interface name %s already exists", ifname)</span>
        })

        <span class="cov8" title="1">return err</span>
}

func confAdd(rt *libcni.RuntimeConf, rawNetconf []byte, multusNetconf *types.NetConf, exec invoke.Exec) (cnitypes.Result, error) <span class="cov8" title="1">{
        logging.Debugf("confAdd: %v, %s", rt, string(rawNetconf))
        // In part, adapted from K8s pkg/kubelet/dockershim/network/cni/cni.go
        binDirs := filepath.SplitList(os.Getenv("CNI_PATH"))
        binDirs = append([]string{multusNetconf.BinDir}, binDirs...)
        cniNet := libcni.NewCNIConfigWithCacheDir(binDirs, multusNetconf.CNIDir, exec)

        conf, err := libcni.ConfFromBytes(rawNetconf)
        if err != nil </span><span class="cov0" title="0">{
                return nil, logging.Errorf("error in converting the raw bytes to conf: %v", err)
        }</span>

        <span class="cov8" title="1">result, err := cniNet.AddNetwork(context.Background(), conf, rt)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return result, nil</span>
}

func confCheck(rt *libcni.RuntimeConf, rawNetconf []byte, multusNetconf *types.NetConf, exec invoke.Exec) error <span class="cov8" title="1">{
        logging.Debugf("confCheck: %v, %s", rt, string(rawNetconf))

        binDirs := filepath.SplitList(os.Getenv("CNI_PATH"))
        binDirs = append([]string{multusNetconf.BinDir}, binDirs...)
        cniNet := libcni.NewCNIConfigWithCacheDir(binDirs, multusNetconf.CNIDir, exec)

        conf, err := libcni.ConfFromBytes(rawNetconf)
        if err != nil </span><span class="cov0" title="0">{
                return logging.Errorf("error in converting the raw bytes to conf: %v", err)
        }</span>

        <span class="cov8" title="1">err = cniNet.CheckNetwork(context.Background(), conf, rt)
        if err != nil </span><span class="cov0" title="0">{
                return logging.Errorf("error in getting result from CheckNetwork: %v", err)
        }</span>

        <span class="cov8" title="1">return err</span>
}

func confDel(rt *libcni.RuntimeConf, rawNetconf []byte, multusNetconf *types.NetConf, exec invoke.Exec) error <span class="cov8" title="1">{
        logging.Debugf("confDel: %v, %s", rt, string(rawNetconf))
        // In part, adapted from K8s pkg/kubelet/dockershim/network/cni/cni.go
        binDirs := filepath.SplitList(os.Getenv("CNI_PATH"))
        binDirs = append([]string{multusNetconf.BinDir}, binDirs...)
        cniNet := libcni.NewCNIConfigWithCacheDir(binDirs, multusNetconf.CNIDir, exec)

        conf, err := libcni.ConfFromBytes(rawNetconf)
        if err != nil </span><span class="cov0" title="0">{
                return logging.Errorf("error in converting the raw bytes to conf: %v", err)
        }</span>

        <span class="cov8" title="1">err = cniNet.DelNetwork(context.Background(), conf, rt)
        if err != nil </span><span class="cov8" title="1">{
                return logging.Errorf("error in getting result from DelNetwork: %v", err)
        }</span>

        <span class="cov8" title="1">return err</span>
}

func conflistAdd(rt *libcni.RuntimeConf, rawnetconflist []byte, multusNetconf *types.NetConf, exec invoke.Exec) (cnitypes.Result, error) <span class="cov8" title="1">{
        logging.Debugf("conflistAdd: %v, %s", rt, string(rawnetconflist))
        // In part, adapted from K8s pkg/kubelet/dockershim/network/cni/cni.go
        binDirs := filepath.SplitList(os.Getenv("CNI_PATH"))
        binDirs = append([]string{multusNetconf.BinDir}, binDirs...)
        cniNet := libcni.NewCNIConfigWithCacheDir(binDirs, multusNetconf.CNIDir, exec)

        confList, err := libcni.ConfListFromBytes(rawnetconflist)
        if err != nil </span><span class="cov0" title="0">{
                return nil, logging.Errorf("conflistAdd: error converting the raw bytes into a conflist: %v", err)
        }</span>

        <span class="cov8" title="1">result, err := cniNet.AddNetworkList(context.Background(), confList, rt)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return result, nil</span>
}

func conflistCheck(rt *libcni.RuntimeConf, rawnetconflist []byte, multusNetconf *types.NetConf, exec invoke.Exec) error <span class="cov8" title="1">{
        logging.Debugf("conflistCheck: %v, %s", rt, string(rawnetconflist))

        binDirs := filepath.SplitList(os.Getenv("CNI_PATH"))
        binDirs = append([]string{multusNetconf.BinDir}, binDirs...)
        cniNet := libcni.NewCNIConfigWithCacheDir(binDirs, multusNetconf.CNIDir, exec)

        confList, err := libcni.ConfListFromBytes(rawnetconflist)
        if err != nil </span><span class="cov0" title="0">{
                return logging.Errorf("conflistCheck: error converting the raw bytes into a conflist: %v", err)
        }</span>

        <span class="cov8" title="1">err = cniNet.CheckNetworkList(context.Background(), confList, rt)
        if err != nil </span><span class="cov0" title="0">{
                return logging.Errorf("conflistCheck: error in getting result from CheckNetworkList: %v", err)
        }</span>

        <span class="cov8" title="1">return err</span>
}

func conflistDel(rt *libcni.RuntimeConf, rawnetconflist []byte, multusNetconf *types.NetConf, exec invoke.Exec) error <span class="cov8" title="1">{
        logging.Debugf("conflistDel: %v, %s", rt, string(rawnetconflist))
        // In part, adapted from K8s pkg/kubelet/dockershim/network/cni/cni.go
        binDirs := filepath.SplitList(os.Getenv("CNI_PATH"))
        binDirs = append([]string{multusNetconf.BinDir}, binDirs...)
        cniNet := libcni.NewCNIConfigWithCacheDir(binDirs, multusNetconf.CNIDir, exec)

        confList, err := libcni.ConfListFromBytes(rawnetconflist)
        if err != nil </span><span class="cov8" title="1">{
                return logging.Errorf("conflistDel: error converting the raw bytes into a conflist: %v", err)
        }</span>

        <span class="cov8" title="1">err = cniNet.DelNetworkList(context.Background(), confList, rt)
        if err != nil </span><span class="cov0" title="0">{
                return logging.Errorf("conflistDel: error in getting result from DelNetworkList: %v", err)
        }</span>

        <span class="cov8" title="1">return err</span>
}

func delegateAdd(exec invoke.Exec, kubeClient *k8s.ClientInfo, pod *v1.Pod, delegate *types.DelegateNetConf, rt *libcni.RuntimeConf, multusNetconf *types.NetConf) (cnitypes.Result, error) <span class="cov8" title="1">{
        logging.Debugf("delegateAdd: %v, %v, %v", exec, delegate, rt)

        if err := validateIfName(rt.NetNS, rt.IfName); err != nil </span><span class="cov8" title="1">{
                return nil, logging.Errorf("delegateAdd: cannot set %q interface name to %q: %v", delegate.Conf.Type, rt.IfName, err)
        }</span>

        // Deprecated in ver 3.5.
        <span class="cov8" title="1">if delegate.MacRequest != "" || delegate.IPRequest != nil </span><span class="cov8" title="1">{
                if delegate.MacRequest != "" </span><span class="cov8" title="1">{
                        // validate Mac address
                        _, err := net.ParseMAC(delegate.MacRequest)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, logging.Errorf("delegateAdd: failed to parse mac address %q", delegate.MacRequest)
                        }</span>

                        <span class="cov8" title="1">logging.Debugf("delegateAdd: set MAC address %q to %q", delegate.MacRequest, rt.IfName)
                        rt.Args = append(rt.Args, [2]string{"MAC", delegate.MacRequest})</span>
                }

                <span class="cov8" title="1">if delegate.IPRequest != nil </span><span class="cov8" title="1">{
                        // validate IP address
                        for _, ip := range delegate.IPRequest </span><span class="cov8" title="1">{
                                if strings.Contains(ip, "/") </span><span class="cov0" title="0">{
                                        _, _, err := net.ParseCIDR(ip)
                                        if err != nil </span><span class="cov0" title="0">{
                                                return nil, logging.Errorf("delegateAdd: failed to parse IP address %q", ip)
                                        }</span>
                                } else<span class="cov8" title="1"> if net.ParseIP(ip) == nil </span><span class="cov0" title="0">{
                                        return nil, logging.Errorf("delegateAdd: failed to parse IP address %q", ip)
                                }</span>
                        }

                        <span class="cov8" title="1">ips := strings.Join(delegate.IPRequest, ",")
                        logging.Debugf("delegateAdd: set IP address %q to %q", ips, rt.IfName)
                        rt.Args = append(rt.Args, [2]string{"IP", ips})</span>
                }
        }

        <span class="cov8" title="1">var result cnitypes.Result
        var err error
        if delegate.ConfListPlugin </span><span class="cov8" title="1">{
                result, err = conflistAdd(rt, delegate.Bytes, multusNetconf, exec)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        } else<span class="cov8" title="1"> {
                result, err = confAdd(rt, delegate.Bytes, multusNetconf, exec)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
        }

        <span class="cov8" title="1">if logging.GetLoggingLevel() &gt;= logging.VerboseLevel </span><span class="cov8" title="1">{
                data, _ := json.Marshal(result)
                var cniConfName string
                if delegate.ConfListPlugin </span><span class="cov8" title="1">{
                        cniConfName = delegate.ConfList.Name
                }</span> else<span class="cov8" title="1"> {
                        cniConfName = delegate.Conf.Name
                }</span>

                <span class="cov8" title="1">podUID := "unknownUID"
                if pod != nil </span><span class="cov8" title="1">{
                        podUID = string(pod.ObjectMeta.UID)
                }</span>
                <span class="cov8" title="1">logging.Verbosef("Add: %s:%s:%s:%s(%s):%s %s", rt.Args[1][1], rt.Args[2][1], podUID, delegate.Name, cniConfName, rt.IfName, string(data))</span>
        }

        // get IP addresses from result
        <span class="cov8" title="1">ips := []string{}
        res, err := cni100.NewResultFromResult(result)
        if err != nil </span><span class="cov0" title="0">{
                logging.Errorf("delegateAdd: error converting result: %v", err)
                return result, nil
        }</span>
        <span class="cov8" title="1">for _, ip := range res.IPs </span><span class="cov8" title="1">{
                ips = append(ips, ip.Address.String())
        }</span>

        <span class="cov8" title="1">if pod != nil </span><span class="cov8" title="1">{
                // send kubernetes events
                if delegate.Name != "" </span><span class="cov8" title="1">{
                        kubeClient.Eventf(pod, v1.EventTypeNormal, "AddedInterface", "Add %s %v from %s", rt.IfName, ips, delegate.Name)
                }</span> else<span class="cov0" title="0"> {
                        kubeClient.Eventf(pod, v1.EventTypeNormal, "AddedInterface", "Add %s %v", rt.IfName, ips)
                }</span>
        } else<span class="cov8" title="1"> {
                // for further debug https://github.com/k8snetworkplumbingwg/multus-cni/issues/481
                logging.Errorf("delegateAdd: pod nil pointer: namespace: %s, name: %s, container id: %s, pod: %v", rt.Args[1][1], rt.Args[2][1], rt.Args[3][1], pod)
        }</span>
        <span class="cov8" title="1">return result, nil</span>
}

func delegateCheck(exec invoke.Exec, delegateConf *types.DelegateNetConf, rt *libcni.RuntimeConf, multusNetconf *types.NetConf) error <span class="cov8" title="1">{
        logging.Debugf("delegateCheck: %v, %v, %v", exec, delegateConf, rt)

        if logging.GetLoggingLevel() &gt;= logging.VerboseLevel </span><span class="cov8" title="1">{
                var cniConfName string
                if delegateConf.ConfListPlugin </span><span class="cov8" title="1">{
                        cniConfName = delegateConf.ConfList.Name
                }</span> else<span class="cov8" title="1"> {
                        cniConfName = delegateConf.Conf.Name
                }</span>
                <span class="cov8" title="1">logging.Verbosef("Check: %s:%s:%s(%s):%s %s", rt.Args[1][1], rt.Args[2][1], delegateConf.Name, cniConfName, rt.IfName, string(delegateConf.Bytes))</span>
        }

        <span class="cov8" title="1">var err error
        if delegateConf.ConfListPlugin </span><span class="cov8" title="1">{
                err = conflistCheck(rt, delegateConf.Bytes, multusNetconf, exec)
                if err != nil </span><span class="cov0" title="0">{
                        return logging.Errorf("delegateCheck: error invoking ConflistCheck - %q: %v", delegateConf.ConfList.Name, err)
                }</span>
        } else<span class="cov8" title="1"> {
                err = confCheck(rt, delegateConf.Bytes, multusNetconf, exec)
                if err != nil </span><span class="cov0" title="0">{
                        return logging.Errorf("delegateCheck: error invoking DelegateCheck - %q: %v", delegateConf.Conf.Type, err)
                }</span>
        }

        <span class="cov8" title="1">return err</span>
}

func delegateDel(exec invoke.Exec, pod *v1.Pod, delegateConf *types.DelegateNetConf, rt *libcni.RuntimeConf, multusNetconf *types.NetConf) error <span class="cov8" title="1">{
        logging.Debugf("delegateDel: %v, %v, %v, %v", exec, pod, delegateConf, rt)

        if logging.GetLoggingLevel() &gt;= logging.VerboseLevel </span><span class="cov8" title="1">{
                var confName string
                if delegateConf.ConfListPlugin </span><span class="cov8" title="1">{
                        confName = delegateConf.ConfList.Name
                }</span> else<span class="cov8" title="1"> {
                        confName = delegateConf.Conf.Name
                }</span>
                <span class="cov8" title="1">podUID := "unknownUID"
                if pod != nil </span><span class="cov8" title="1">{
                        podUID = string(pod.ObjectMeta.UID)
                }</span>
                <span class="cov8" title="1">logging.Verbosef("Del: %s:%s:%s:%s:%s %s", rt.Args[1][1], rt.Args[2][1], podUID, confName, rt.IfName, string(delegateConf.Bytes))</span>
        }

        <span class="cov8" title="1">var err error
        if delegateConf.ConfListPlugin </span><span class="cov8" title="1">{
                err = conflistDel(rt, delegateConf.Bytes, multusNetconf, exec)
                if err != nil </span><span class="cov0" title="0">{
                        return logging.Errorf("delegateDel: error invoking ConflistDel - %q: %v", delegateConf.ConfList.Name, err)
                }</span>
        } else<span class="cov8" title="1"> {
                err = confDel(rt, delegateConf.Bytes, multusNetconf, exec)
                if err != nil </span><span class="cov8" title="1">{
                        return logging.Errorf("delegateDel: error invoking DelegateDel - %q: %v", delegateConf.Conf.Type, err)
                }</span>
        }

        <span class="cov8" title="1">return err</span>
}

// delPlugins deletes plugins in reverse order from lastdIdx
// Uses netRt as base RuntimeConf (coming from NetConf) but merges it
// with each of the delegates' configuration
func delPlugins(exec invoke.Exec, pod *v1.Pod, args *skel.CmdArgs, k8sArgs *types.K8sArgs, delegates []*types.DelegateNetConf, lastIdx int, netRt *types.RuntimeConfig, multusNetconf *types.NetConf) error <span class="cov8" title="1">{
        logging.Debugf("delPlugins: %v, %v, %v, %v, %v, %d, %v", exec, pod, args, k8sArgs, delegates, lastIdx, netRt)

        var errorstrings []string
        for idx := lastIdx; idx &gt;= 0; idx-- </span><span class="cov8" title="1">{
                ifName := getIfname(delegates[idx], args.IfName, idx)
                rt, cniDeviceInfoPath := types.CreateCNIRuntimeConf(args, k8sArgs, ifName, netRt, delegates[idx])
                // Attempt to delete all but do not error out, instead, collect all errors.
                if err := delegateDel(exec, pod, delegates[idx], rt, multusNetconf); err != nil </span><span class="cov8" title="1">{
                        errorstrings = append(errorstrings, err.Error())
                }</span>
                <span class="cov8" title="1">if cniDeviceInfoPath != "" </span><span class="cov0" title="0">{
                        err := nadutils.CleanDeviceInfoForCNI(cniDeviceInfoPath)
                        // Even if the filename is set, file may not be present. Ignore error,
                        // but log and in the future may need to filter on specific errors.
                        if err != nil </span><span class="cov0" title="0">{
                                logging.Debugf("delPlugins: CleanDeviceInfoForCNI returned an error - err=%v", err)
                        }</span>
                }
        }

        // Check if we had any errors, and send them all back.
        <span class="cov8" title="1">if len(errorstrings) &gt; 0 </span><span class="cov8" title="1">{
                return fmt.Errorf(strings.Join(errorstrings, " / "))
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func cmdErr(k8sArgs *types.K8sArgs, format string, args ...interface{}) error <span class="cov8" title="1">{
        prefix := "Multus: "
        if k8sArgs != nil </span><span class="cov8" title="1">{
                prefix += fmt.Sprintf("[%s/%s/%s]: ", k8sArgs.K8S_POD_NAMESPACE, k8sArgs.K8S_POD_NAME, k8sArgs.K8S_POD_UID)
        }</span>
        <span class="cov8" title="1">return logging.Errorf(prefix+format, args...)</span>
}

func cmdPluginErr(k8sArgs *types.K8sArgs, confName string, format string, args ...interface{}) error <span class="cov8" title="1">{
        msg := ""
        if k8sArgs != nil </span><span class="cov8" title="1">{
                msg += fmt.Sprintf("[%s/%s/%s:%s]: ", k8sArgs.K8S_POD_NAMESPACE, k8sArgs.K8S_POD_NAME, k8sArgs.K8S_POD_UID, confName)
        }</span>
        <span class="cov8" title="1">return logging.Errorf(msg+format, args...)</span>
}

func isCriticalRequestRetriable(err error) bool <span class="cov8" title="1">{
        logging.Debugf("isCriticalRequestRetriable: %v", err)
        errorTypesAllowingRetry := []func(error) bool{
                errors.IsServiceUnavailable, errors.IsInternalError, k8snet.IsConnectionReset, k8snet.IsConnectionRefused}
        for _, f := range errorTypesAllowingRetry </span><span class="cov8" title="1">{
                if f(err) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

func getPod(kubeClient *k8s.ClientInfo, k8sArgs *types.K8sArgs, warnOnly bool) (*v1.Pod, error) <span class="cov8" title="1">{
        if kubeClient == nil </span><span class="cov8" title="1">{
                return nil, nil
        }</span>

        <span class="cov8" title="1">podNamespace := string(k8sArgs.K8S_POD_NAMESPACE)
        podName := string(k8sArgs.K8S_POD_NAME)
        podUID := string(k8sArgs.K8S_POD_UID)

        pod, err := kubeClient.GetPod(podNamespace, podName)
        if err != nil </span><span class="cov8" title="1">{
                // in case of a retriable error, retry 10 times with 0.25 sec interval
                if isCriticalRequestRetriable(err) </span><span class="cov0" title="0">{
                        waitErr := wait.PollImmediate(shortPollDuration, shortPollTimeout, func() (bool, error) </span><span class="cov0" title="0">{
                                pod, err = kubeClient.GetPod(podNamespace, podName)
                                return pod != nil, err
                        }</span>)
                        // retry failed, then return error with retry out
                        <span class="cov0" title="0">if waitErr != nil </span><span class="cov0" title="0">{
                                return nil, cmdErr(k8sArgs, "error waiting for pod: %v", err)
                        }</span>
                } else<span class="cov8" title="1"> if warnOnly &amp;&amp; errors.IsNotFound(err) </span><span class="cov8" title="1">{
                        // If not found, proceed to remove interface with cache
                        return nil, nil
                }</span> else<span class="cov0" title="0"> {
                        // Other case, return error
                        return nil, cmdErr(k8sArgs, "error getting pod: %v", err)
                }</span>
        }

        // In case of static pod, UID through kube api is different because of mirror pod, hence it is expected.
        <span class="cov8" title="1">if podUID != "" &amp;&amp; string(pod.UID) != podUID &amp;&amp; !k8s.IsStaticPod(pod) </span><span class="cov8" title="1">{
                msg := fmt.Sprintf("expected pod UID %q but got %q from Kube API", podUID, pod.UID)
                if warnOnly </span><span class="cov0" title="0">{
                        // On CNI DEL we just operate on the cache when these mismatch, we don't error out.
                        // For example: stateful sets namespace/name can remain the same while podUID changes.
                        logging.Verbosef("warning: %s", msg)
                        return nil, nil
                }</span>
                <span class="cov8" title="1">return nil, cmdErr(k8sArgs, msg)</span>
        }

        <span class="cov8" title="1">return pod, nil</span>
}

//CmdAdd ...
func CmdAdd(args *skel.CmdArgs, exec invoke.Exec, kubeClient *k8s.ClientInfo) (cnitypes.Result, error) <span class="cov8" title="1">{
        n, err := types.LoadNetConf(args.StdinData)
        logging.Debugf("CmdAdd: %v, %v, %v", args, exec, kubeClient)
        if err != nil </span><span class="cov8" title="1">{
                return nil, cmdErr(nil, "error loading netconf: %v", err)
        }</span>

        <span class="cov8" title="1">kubeClient, err = k8s.GetK8sClient(n.Kubeconfig, kubeClient)
        if err != nil </span><span class="cov0" title="0">{
                return nil, cmdErr(nil, "error getting k8s client: %v", err)
        }</span>

        <span class="cov8" title="1">k8sArgs, err := k8s.GetK8sArgs(args)
        if err != nil </span><span class="cov0" title="0">{
                return nil, cmdErr(nil, "error getting k8s args: %v", err)
        }</span>

        <span class="cov8" title="1">if n.ReadinessIndicatorFile != "" </span><span class="cov0" title="0">{
                err := wait.PollImmediate(pollDuration, pollTimeout, func() (bool, error) </span><span class="cov0" title="0">{
                        _, err := os.Stat(n.ReadinessIndicatorFile)
                        return err == nil, nil
                }</span>)
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        return nil, cmdErr(k8sArgs, "have you checked that your default network is ready? still waiting for readinessindicatorfile @ %v. pollimmediate error: %v", n.ReadinessIndicatorFile, err)
                }</span>
        }

        <span class="cov8" title="1">pod, err := getPod(kubeClient, k8sArgs, false)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        // resourceMap holds Pod device allocation information; only initizized if CRD contains 'resourceName' annotation.
        // This will only be initialized once and all delegate objects can reference this to look up device info.
        <span class="cov8" title="1">var resourceMap map[string]*types.ResourceInfo

        if n.ClusterNetwork != "" </span><span class="cov8" title="1">{
                resourceMap, err = k8s.GetDefaultNetworks(pod, n, kubeClient, resourceMap)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, cmdErr(k8sArgs, "failed to get clusterNetwork/defaultNetworks: %v", err)
                }</span>
                // First delegate is always the master plugin
                <span class="cov8" title="1">n.Delegates[0].MasterPlugin = true</span>
        }

        <span class="cov8" title="1">_, kc, err := k8s.TryLoadPodDelegates(pod, n, kubeClient, resourceMap)
        if err != nil </span><span class="cov0" title="0">{
                return nil, cmdErr(k8sArgs, "error loading k8s delegates k8s args: %v", err)
        }</span>

        // cache the multus config
        <span class="cov8" title="1">if err := saveDelegates(args.ContainerID, n.CNIDir, n.Delegates); err != nil </span><span class="cov0" title="0">{
                return nil, cmdErr(k8sArgs, "error saving the delegates: %v", err)
        }</span>

        <span class="cov8" title="1">var result, tmpResult cnitypes.Result
        var netStatus []nettypes.NetworkStatus
        for idx, delegate := range n.Delegates </span><span class="cov8" title="1">{
                ifName := getIfname(delegate, args.IfName, idx)
                rt, cniDeviceInfoPath := types.CreateCNIRuntimeConf(args, k8sArgs, ifName, n.RuntimeConfig, delegate)
                if cniDeviceInfoPath != "" &amp;&amp; delegate.ResourceName != "" &amp;&amp; delegate.DeviceID != "" </span><span class="cov0" title="0">{
                        err = nadutils.CopyDeviceInfoForCNIFromDP(cniDeviceInfoPath, delegate.ResourceName, delegate.DeviceID)
                        // Even if the filename is set, file may not be present. Ignore error,
                        // but log and in the future may need to filter on specific errors.
                        if err != nil </span><span class="cov0" title="0">{
                                logging.Debugf("CmdAdd: CopyDeviceInfoForCNIFromDP returned an error - err=%v", err)
                        }</span>
                }

                // We collect the delegate netName for the cachefile name as well as following errors
                <span class="cov8" title="1">netName := delegate.Conf.Name
                if netName == "" </span><span class="cov8" title="1">{
                        netName = delegate.ConfList.Name
                }</span>
                <span class="cov8" title="1">tmpResult, err = delegateAdd(exec, kubeClient, pod, delegate, rt, n)
                if err != nil </span><span class="cov8" title="1">{
                        // If the add failed, tear down all networks we already added
                        // Ignore errors; DEL must be idempotent anyway
                        _ = delPlugins(exec, nil, args, k8sArgs, n.Delegates, idx, n.RuntimeConfig, n)
                        return nil, cmdPluginErr(k8sArgs, netName, "error adding container to network %q: %v", netName, err)
                }</span>

                // Remove gateway from routing table if the gateway is not used
                <span class="cov8" title="1">deleteV4gateway := false
                deleteV6gateway := false
                adddefaultgateway := false
                if delegate.IsFilterV4Gateway </span><span class="cov0" title="0">{
                        deleteV4gateway = true
                        logging.Debugf("Marked interface %v for v4 gateway deletion", ifName)
                }</span> else<span class="cov8" title="1"> {
                        // Otherwise, determine if this interface now gets our default route.
                        // According to
                        // https://docs.google.com/document/d/1Ny03h6IDVy_e_vmElOqR7UdTPAG_RNydhVE1Kx54kFQ (4.1.2.1.9)
                        // the list can be empty; if it is, we'll assume the CNI's config for the default gateway holds,
                        // else we'll update the defaultgateway to the one specified.
                        if delegate.GatewayRequest != nil &amp;&amp; delegate.GatewayRequest[0] != nil </span><span class="cov0" title="0">{
                                deleteV4gateway = true
                                adddefaultgateway = true
                                logging.Debugf("Detected gateway override on interface %v to %v", ifName, delegate.GatewayRequest)
                        }</span>
                }

                <span class="cov8" title="1">if delegate.IsFilterV6Gateway </span><span class="cov0" title="0">{
                        deleteV6gateway = true
                        logging.Debugf("Marked interface %v for v6 gateway deletion", ifName)
                }</span> else<span class="cov8" title="1"> {
                        // Otherwise, determine if this interface now gets our default route.
                        // According to
                        // https://docs.google.com/document/d/1Ny03h6IDVy_e_vmElOqR7UdTPAG_RNydhVE1Kx54kFQ (4.1.2.1.9)
                        // the list can be empty; if it is, we'll assume the CNI's config for the default gateway holds,
                        // else we'll update the defaultgateway to the one specified.
                        if delegate.GatewayRequest != nil &amp;&amp; delegate.GatewayRequest[0] != nil </span><span class="cov0" title="0">{
                                deleteV6gateway = true
                                adddefaultgateway = true
                                logging.Debugf("Detected gateway override on interface %v to %v", ifName, delegate.GatewayRequest)
                        }</span>
                }

                // Remove gateway if `default-route` network selection is specified
                <span class="cov8" title="1">if deleteV4gateway || deleteV6gateway </span><span class="cov0" title="0">{
                        err = netutils.DeleteDefaultGW(args.Netns, ifName)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, cmdErr(k8sArgs, "error deleting default gateway: %v", err)
                        }</span>
                        <span class="cov0" title="0">err = netutils.DeleteDefaultGWCache(n.CNIDir, rt, netName, ifName, deleteV4gateway, deleteV6gateway)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, cmdErr(k8sArgs, "error deleting default gateway in cache: %v", err)
                        }</span>
                }

                // Here we'll set the default gateway which specified in `default-route` network selection
                <span class="cov8" title="1">if adddefaultgateway </span><span class="cov0" title="0">{
                        err = netutils.SetDefaultGW(args.Netns, ifName, delegate.GatewayRequest)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, cmdErr(k8sArgs, "error setting default gateway: %v", err)
                        }</span>
                        <span class="cov0" title="0">err = netutils.AddDefaultGWCache(n.CNIDir, rt, netName, ifName, delegate.GatewayRequest)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, cmdErr(k8sArgs, "error setting default gateway in cache: %v", err)
                        }</span>
                }

                // Master plugin result is always used if present
                <span class="cov8" title="1">if delegate.MasterPlugin || result == nil </span><span class="cov8" title="1">{
                        result = tmpResult
                }</span>

                // Read devInfo from CNIDeviceInfoFile if it exists so
                // it can be copied to the NetworkStatus.
                <span class="cov8" title="1">devinfo, err := getDelegateDeviceInfo(delegate, rt)
                if err != nil </span><span class="cov0" title="0">{
                        // Even if the filename is set, file may not be present. Ignore error,
                        // but log and in the future may need to filter on specific errors.
                        logging.Debugf("CmdAdd: getDelegateDeviceInfo returned an error - err=%v", err)
                }</span>

                // create the network status, only in case Multus as kubeconfig
                <span class="cov8" title="1">if kubeClient != nil &amp;&amp; kc != nil </span><span class="cov8" title="1">{
                        if !types.CheckSystemNamespaces(string(k8sArgs.K8S_POD_NAME), n.SystemNamespaces) </span><span class="cov8" title="1">{
                                delegateNetStatus, err := nadutils.CreateNetworkStatus(tmpResult, delegate.Name, delegate.MasterPlugin, devinfo)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, cmdErr(k8sArgs, "error setting network status: %v", err)
                                }</span>

                                <span class="cov8" title="1">netStatus = append(netStatus, *delegateNetStatus)</span>
                        }
                } else<span class="cov8" title="1"> if devinfo != nil </span><span class="cov0" title="0">{
                        // Warn that devinfo exists but could not add it to downwards API
                        logging.Errorf("devinfo available, but no kubeConfig so NetworkStatus not modified.")
                }</span>
        }

        // set the network status annotation in apiserver, only in case Multus as kubeconfig
        <span class="cov8" title="1">if kubeClient != nil &amp;&amp; kc != nil </span><span class="cov8" title="1">{
                if !types.CheckSystemNamespaces(string(k8sArgs.K8S_POD_NAME), n.SystemNamespaces) </span><span class="cov8" title="1">{
                        err = k8s.SetNetworkStatus(kubeClient, k8sArgs, netStatus, n)
                        if err != nil </span><span class="cov0" title="0">{
                                if strings.Contains(err.Error(), "failed to query the pod") </span><span class="cov0" title="0">{
                                        return nil, cmdErr(k8sArgs, "error setting the networks status, pod was already deleted: %v", err)
                                }</span>
                                <span class="cov0" title="0">return nil, cmdErr(k8sArgs, "error setting the networks status: %v", err)</span>
                        }
                }
        }

        <span class="cov8" title="1">return result, nil</span>
}

//CmdCheck ...
func CmdCheck(args *skel.CmdArgs, exec invoke.Exec, kubeClient *k8s.ClientInfo) error <span class="cov8" title="1">{
        in, err := types.LoadNetConf(args.StdinData)
        logging.Debugf("CmdCheck: %v, %v, %v", args, exec, kubeClient)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">k8sArgs, err := k8s.GetK8sArgs(args)
        if err != nil </span><span class="cov0" title="0">{
                return cmdErr(nil, "error getting k8s args: %v", err)
        }</span>

        <span class="cov8" title="1">for idx, delegate := range in.Delegates </span><span class="cov8" title="1">{
                ifName := getIfname(delegate, args.IfName, idx)

                rt, _ := types.CreateCNIRuntimeConf(args, k8sArgs, ifName, in.RuntimeConfig, delegate)
                err = delegateCheck(exec, delegate, rt, in)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

//CmdDel ...
func CmdDel(args *skel.CmdArgs, exec invoke.Exec, kubeClient *k8s.ClientInfo) error <span class="cov8" title="1">{
        in, err := types.LoadNetConf(args.StdinData)
        logging.Debugf("CmdDel: %v, %v, %v", args, exec, kubeClient)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">netnsfound := true
        netns, err := ns.GetNS(args.Netns)
        if err != nil </span><span class="cov0" title="0">{
                // if NetNs is passed down by the Cloud Orchestration Engine, or if it called multiple times
                // so don't return an error if the device is already removed.
                // https://github.com/kubernetes/kubernetes/issues/43014#issuecomment-287164444
                _, ok := err.(ns.NSPathNotExistErr)
                netnsfound = false
                if ok </span><span class="cov0" title="0">{
                        logging.Debugf("CmdDel: WARNING netns may not exist, netns: %s, err: %s", args.Netns, err)
                }</span> else<span class="cov0" title="0"> {
                        logging.Debugf("CmdDel: WARNING failed to open netns %q: %v", netns, err)
                }</span>
        }

        <span class="cov8" title="1">if netns != nil </span><span class="cov8" title="1">{
                defer netns.Close()
        }</span>

        <span class="cov8" title="1">k8sArgs, err := k8s.GetK8sArgs(args)
        if err != nil </span><span class="cov0" title="0">{
                return cmdErr(nil, "error getting k8s args: %v", err)
        }</span>

        <span class="cov8" title="1">if in.ReadinessIndicatorFile != "" </span><span class="cov0" title="0">{
                err := wait.PollImmediate(pollDuration, pollTimeout, func() (bool, error) </span><span class="cov0" title="0">{
                        _, err := os.Stat(in.ReadinessIndicatorFile)
                        return err == nil, nil
                }</span>)
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        return cmdErr(k8sArgs, "PollImmediate error waiting for ReadinessIndicatorFile (on del): %v", err)
                }</span>
        }

        <span class="cov8" title="1">kubeClient, err = k8s.GetK8sClient(in.Kubeconfig, kubeClient)
        if err != nil </span><span class="cov0" title="0">{
                return cmdErr(nil, "error getting k8s client: %v", err)
        }</span>

        <span class="cov8" title="1">pod, err := getPod(kubeClient, k8sArgs, true)
        if err != nil </span><span class="cov0" title="0">{
                // getPod may be failed but just do print error in its log and continue to delete
                logging.Errorf("Multus: getPod failed: %v, but continue to delete", err)
        }</span>

        // Read the cache to get delegates json for the pod
        <span class="cov8" title="1">netconfBytes, path, err := consumeScratchNetConf(args.ContainerID, in.CNIDir)
        if err != nil </span><span class="cov8" title="1">{
                // Fetch delegates again if cache is not exist and pod info can be read
                if os.IsNotExist(err) &amp;&amp; pod != nil </span><span class="cov8" title="1">{
                        if in.ClusterNetwork != "" </span><span class="cov0" title="0">{
                                _, err = k8s.GetDefaultNetworks(pod, in, kubeClient, nil)
                                if err != nil </span><span class="cov0" title="0">{
                                        return cmdErr(k8sArgs, "failed to get clusterNetwork/defaultNetworks: %v", err)
                                }</span>
                                // First delegate is always the master plugin
                                <span class="cov0" title="0">in.Delegates[0].MasterPlugin = true</span>
                        }

                        // Get pod annotation and so on
                        <span class="cov8" title="1">_, _, err := k8s.TryLoadPodDelegates(pod, in, kubeClient, nil)
                        if err != nil </span><span class="cov0" title="0">{
                                if len(in.Delegates) == 0 </span><span class="cov0" title="0">{
                                        // No delegate available so send error
                                        return cmdErr(k8sArgs, "failed to get delegates: %v", err)
                                }</span>
                                // Get clusterNetwork before, so continue to delete
                                <span class="cov0" title="0">logging.Errorf("Multus: failed to get delegates: %v, but continue to delete clusterNetwork", err)</span>
                        }
                } else<span class="cov0" title="0"> {
                        // The options to continue with a delete have been exhausted (cachefile + API query didn't work)
                        // We cannot exit with an error as this may cause a sandbox to never get deleted.
                        logging.Errorf("Multus: failed to get the cached delegates file: %v, cannot properly delete", err)
                        return nil
                }</span>
        } else<span class="cov8" title="1"> {
                defer os.Remove(path)
                if err := json.Unmarshal(netconfBytes, &amp;in.Delegates); err != nil </span><span class="cov0" title="0">{
                        return cmdErr(k8sArgs, "failed to load netconf: %v", err)
                }</span>
                // check plugins field and enable ConfListPlugin if there is
                <span class="cov8" title="1">for _, v := range in.Delegates </span><span class="cov8" title="1">{
                        if len(v.ConfList.Plugins) != 0 </span><span class="cov8" title="1">{
                                v.ConfListPlugin = true
                        }</span>
                }
                // First delegate is always the master plugin
                <span class="cov8" title="1">in.Delegates[0].MasterPlugin = true</span>
        }

        // set CNIVersion in delegate CNI config if there is no CNIVersion and multus conf have CNIVersion.
        <span class="cov8" title="1">for _, v := range in.Delegates </span><span class="cov8" title="1">{
                if v.ConfListPlugin == true &amp;&amp; v.ConfList.CNIVersion == "" &amp;&amp; in.CNIVersion != "" </span><span class="cov0" title="0">{
                        v.ConfList.CNIVersion = in.CNIVersion
                        v.Bytes, err = json.Marshal(v.ConfList)
                        if err != nil </span><span class="cov0" title="0">{
                                // error happen but continue to delete
                                logging.Errorf("Multus: failed to marshal delegate %q config: %v", v.Name, err)
                        }</span>
                }
        }

        // unset the network status annotation in apiserver, only in case Multus as kubeconfig
        <span class="cov8" title="1">if kubeClient != nil </span><span class="cov8" title="1">{
                if netnsfound </span><span class="cov8" title="1">{
                        if !types.CheckSystemNamespaces(string(k8sArgs.K8S_POD_NAMESPACE), in.SystemNamespaces) </span><span class="cov8" title="1">{
                                err := k8s.SetNetworkStatus(kubeClient, k8sArgs, nil, in)
                                if err != nil </span><span class="cov8" title="1">{
                                        // error happen but continue to delete
                                        logging.Errorf("Multus: error unsetting the networks status: %v", err)
                                }</span>
                        }
                } else<span class="cov0" title="0"> {
                        logging.Debugf("WARNING: Unset SetNetworkStatus skipped due to netns not found.")
                }</span>
        }

        <span class="cov8" title="1">return delPlugins(exec, pod, args, k8sArgs, in.Delegates, len(in.Delegates)-1, in.RuntimeConfig, in)</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">// Copyright (c) 2019 Multus Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

package netutils

import (
        "encoding/json"
        "fmt"
        "io/ioutil"
        "net"
        "path/filepath"

        "github.com/containernetworking/cni/libcni"
        "github.com/containernetworking/plugins/pkg/ns"
        "github.com/vishvananda/netlink"
        "gopkg.in/k8snetworkplumbingwg/multus-cni.v3/pkg/logging"
)

// DeleteDefaultGW removes the default gateway from marked interfaces.
func DeleteDefaultGW(netnsPath string, ifName string) error <span class="cov8" title="1">{
        netns, err := ns.GetNS(netnsPath)
        if err != nil </span><span class="cov0" title="0">{
                return logging.Errorf("DeleteDefaultGW: Error getting namespace %v", err)
        }</span>
        <span class="cov8" title="1">defer netns.Close()

        err = netns.Do(func(_ ns.NetNS) error </span><span class="cov8" title="1">{
                var err error
                link, _ := netlink.LinkByName(ifName)
                routes, _ := netlink.RouteList(link, netlink.FAMILY_ALL)
                for _, nlroute := range routes </span><span class="cov8" title="1">{
                        if nlroute.Dst == nil </span><span class="cov8" title="1">{
                                err = netlink.RouteDel(&amp;nlroute)
                        }</span>
                }
                <span class="cov8" title="1">return err</span>
        })
        <span class="cov8" title="1">return err</span>
}

// SetDefaultGW adds a default gateway on a specific interface
func SetDefaultGW(netnsPath string, ifName string, gateways []net.IP) error <span class="cov8" title="1">{
        // This ensures we're acting within the net namespace for the pod.
        netns, err := ns.GetNS(netnsPath)
        if err != nil </span><span class="cov0" title="0">{
                return logging.Errorf("SetDefaultGW: Error getting namespace %v", err)
        }</span>
        <span class="cov8" title="1">defer netns.Close()

        // Do this within the net namespace.
        err = netns.Do(func(_ ns.NetNS) error </span><span class="cov8" title="1">{
                var err error

                // Pick up the link info as we need the index.
                link, err := netlink.LinkByName(ifName)
                if err != nil </span><span class="cov0" title="0">{
                        return logging.Errorf("SetDefaultGW: Error getting link %v", err)
                }</span>

                // Cycle through all the desired gateways.
                <span class="cov8" title="1">for _, gw := range gateways </span><span class="cov8" title="1">{

                        // Create a new route (note: dst is nil by default)
                        logging.Debugf("SetDefaultGW: Adding default route on %v (index: %v) to %v", ifName, link.Attrs().Index, gw)
                        newDefaultRoute := netlink.Route{
                                LinkIndex: link.Attrs().Index,
                                Gw:        gw,
                        }

                        // Perform the creation of the default route....
                        err = netlink.RouteAdd(&amp;newDefaultRoute)
                        if err != nil </span><span class="cov0" title="0">{
                                logging.Errorf("SetDefaultGW: Error adding route: %v", err)
                        }</span>
                }
                <span class="cov8" title="1">return err</span>
        })

        <span class="cov8" title="1">return err</span>
}

// DeleteDefaultGWCache updates libcni cache to remove default gateway routes in result
func DeleteDefaultGWCache(cacheDir string, rt *libcni.RuntimeConf, netName string, ifName string, ipv4, ipv6 bool) error <span class="cov0" title="0">{
        cacheFile := filepath.Join(cacheDir, "results", fmt.Sprintf("%s-%s-%s", netName, rt.ContainerID, rt.IfName))

        cache, err := ioutil.ReadFile(cacheFile)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">logging.Debugf("DeleteDefaultGWCache: update cache to delete GW from: %s", string(cache))
        newCache, err := deleteDefaultGWCacheBytes(cache, ipv4, ipv6)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">logging.Debugf("DeleteDefaultGWCache: update cache to delete GW: %s", string(newCache))
        return ioutil.WriteFile(cacheFile, newCache, 0600)</span>
}

func deleteDefaultGWCacheBytes(cacheFile []byte, ipv4, ipv6 bool) ([]byte, error) <span class="cov8" title="1">{
        var cachedInfo map[string]interface{}
        if err := json.Unmarshal(cacheFile, &amp;cachedInfo); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // try to get result
        <span class="cov8" title="1">_, ok := cachedInfo["result"]
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("cannot get result from cache")
        }</span>

        <span class="cov8" title="1">resultJSON, ok := cachedInfo["result"].(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("wrong result type: %v", cachedInfo["result"])
        }</span>
        <span class="cov8" title="1">newResult, err := deleteDefaultGWResult(resultJSON, ipv4, ipv6)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">cachedInfo["result"] = newResult

        newCache, err := json.Marshal(cachedInfo)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to encode json: %v", err)
        }</span>
        <span class="cov8" title="1">return newCache, nil</span>
}

func deleteDefaultGWResultRoutes(routes []interface{}, dstGW string) ([]interface{}, error) <span class="cov8" title="1">{
        for i, r := range routes </span><span class="cov8" title="1">{
                route, ok := r.(map[string]interface{})
                if !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("wrong route format: %v", r)
                }</span>
                <span class="cov8" title="1">_, ok = route["dst"]
                if ok </span><span class="cov8" title="1">{
                        dst, ok := route["dst"].(string)
                        if !ok </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("wrong dst format: %v", route["dst"])
                        }</span>
                        <span class="cov8" title="1">if dst == dstGW </span><span class="cov8" title="1">{
                                routes = append(routes[:i], routes[i+1:]...)
                        }</span>
                }
        }
        <span class="cov8" title="1">return routes, nil</span>
}

func deleteDefaultGWResult(result map[string]interface{}, ipv4, ipv6 bool) (map[string]interface{}, error) <span class="cov8" title="1">{
        // try to get cniVersion from result
        _, ok := result["cniVersion"]
        if !ok </span><span class="cov8" title="1">{
                // fallback to processing result for old cni version(0.1.0/0.2.0)
                return deleteDefaultGWResult020(result, ipv4, ipv6)
        }</span>

        <span class="cov8" title="1">cniVersion, ok := result["cniVersion"].(string)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("wrong cniVersion format: %v", result["cniVersion"])
        }</span>

        <span class="cov8" title="1">if cniVersion == "0.1.0" || cniVersion == "0.2.0" </span><span class="cov0" title="0">{
                // fallback to processing result for old cni version(0.1.0/0.2.0)
                return deleteDefaultGWResult020(result, ipv4, ipv6)
        }</span>

        <span class="cov8" title="1">if cniVersion != "0.3.0" &amp;&amp; cniVersion != "0.3.1" &amp;&amp; cniVersion != "0.4.0" &amp;&amp; cniVersion != "1.0.0" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("not supported version: %s", cniVersion)
        }</span>

        <span class="cov8" title="1">_, ok = result["routes"]
        if !ok </span><span class="cov0" title="0">{
                // No route in result, hence we do nothing
                return result, nil
        }</span>
        <span class="cov8" title="1">routes, ok := result["routes"].([]interface{})
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("wrong routes format: %v", result["routes"])
        }</span>

        <span class="cov8" title="1">var err error
        // delete IPv4 default routes
        if ipv4 </span><span class="cov8" title="1">{
                routes, err = deleteDefaultGWResultRoutes(routes, "0.0.0.0/0")
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov8" title="1">if ipv6 </span><span class="cov8" title="1">{
                routes, err = deleteDefaultGWResultRoutes(routes, "::0/0")
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov8" title="1">result["routes"] = routes

        return result, nil</span>
}

func deleteDefaultGWResult020(result map[string]interface{}, ipv4, ipv6 bool) (map[string]interface{}, error) <span class="cov8" title="1">{
        var err error
        if ipv4 </span><span class="cov8" title="1">{
                _, ok := result["ip4"]
                if ok </span><span class="cov8" title="1">{
                        ip4, ok := result["ip4"].(map[string]interface{})
                        if !ok </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("wrong ip4 format: %v", result["ip4"])
                        }</span>

                        <span class="cov8" title="1">_, ok = ip4["routes"]
                        if ok </span><span class="cov8" title="1">{
                                routes, ok := ip4["routes"].([]interface{})
                                if !ok </span><span class="cov0" title="0">{
                                        return nil, fmt.Errorf("wrong ip4 routes format: %v", ip4["routes"])
                                }</span>

                                <span class="cov8" title="1">routes, err = deleteDefaultGWResultRoutes(routes, "0.0.0.0/0")
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>
                                <span class="cov8" title="1">ip4["routes"] = routes</span>
                        }
                }
        }

        <span class="cov8" title="1">if ipv6 </span><span class="cov8" title="1">{
                _, ok := result["ip6"]
                if ok </span><span class="cov8" title="1">{
                        ip6, ok := result["ip6"].(map[string]interface{})
                        if !ok </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("wrong ip6 format: %v", result["ip6"])
                        }</span>

                        <span class="cov8" title="1">_, ok = ip6["routes"]
                        if ok </span><span class="cov8" title="1">{
                                routes, ok := ip6["routes"].([]interface{})
                                if !ok </span><span class="cov0" title="0">{
                                        return nil, fmt.Errorf("wrong ip6 routes format: %v", ip6["routes"])
                                }</span>

                                <span class="cov8" title="1">routes, err = deleteDefaultGWResultRoutes(routes, "::0/0")
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>
                                <span class="cov8" title="1">ip6["routes"] = routes</span>
                        }
                }
        }

        <span class="cov8" title="1">return result, nil</span>
}

// AddDefaultGWCache updates libcni cache to add default gateway result
func AddDefaultGWCache(cacheDir string, rt *libcni.RuntimeConf, netName string, ifName string, gw []net.IP) error <span class="cov0" title="0">{
        cacheFile := filepath.Join(cacheDir, "results", fmt.Sprintf("%s-%s-%s", netName, rt.ContainerID, rt.IfName))

        cache, err := ioutil.ReadFile(cacheFile)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">logging.Debugf("AddDefaultGWCache: update cache to add GW from: %s", string(cache))
        newCache, err := addDefaultGWCacheBytes(cache, gw)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">logging.Debugf("AddDefaultGWCache: update cache to add GW: %s", string(newCache))
        return ioutil.WriteFile(cacheFile, newCache, 0600)</span>
}

func addDefaultGWCacheBytes(cacheFile []byte, gw []net.IP) ([]byte, error) <span class="cov8" title="1">{
        var cachedInfo map[string]interface{}
        if err := json.Unmarshal(cacheFile, &amp;cachedInfo); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // try to get result
        <span class="cov8" title="1">_, ok := cachedInfo["result"]
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("cannot get result from cache")
        }</span>

        <span class="cov8" title="1">resultJSON, ok := cachedInfo["result"].(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("wrong result type: %v", cachedInfo["result"])
        }</span>
        <span class="cov8" title="1">newResult, err := addDefaultGWResult(resultJSON, gw)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">cachedInfo["result"] = newResult

        newCache, err := json.Marshal(cachedInfo)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to encode json: %v", err)
        }</span>
        <span class="cov8" title="1">return newCache, nil</span>
}

func addDefaultGWResult(result map[string]interface{}, gw []net.IP) (map[string]interface{}, error) <span class="cov8" title="1">{
        // try to get cniVersion from result
        _, ok := result["cniVersion"]
        if !ok </span><span class="cov8" title="1">{
                // fallback to processing result for old cni version(0.1.0/0.2.0)
                return addDefaultGWResult020(result, gw)
        }</span>

        <span class="cov8" title="1">cniVersion, ok := result["cniVersion"].(string)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("wrong cniVersion format: %v", result["cniVersion"])
        }</span>

        <span class="cov8" title="1">if cniVersion == "0.1.0" || cniVersion == "0.2.0" </span><span class="cov0" title="0">{
                // fallback to processing result for old cni version(0.1.0/0.2.0)
                return addDefaultGWResult020(result, gw)
        }</span>

        <span class="cov8" title="1">if cniVersion != "0.3.0" &amp;&amp; cniVersion != "0.3.1" &amp;&amp; cniVersion != "0.4.0" &amp;&amp; cniVersion != "1.0.0" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("not supported version: %s", cniVersion)
        }</span>

        <span class="cov8" title="1">routes := []interface{}{}
        _, ok = result["routes"]
        if ok </span><span class="cov8" title="1">{
                routes, ok = result["routes"].([]interface{})
                if !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("wrong routes format: %v", result["routes"])
                }</span>
        }

        <span class="cov8" title="1">for _, g := range gw </span><span class="cov8" title="1">{
                dst := "0.0.0.0/0"
                if g.To4() == nil </span><span class="cov8" title="1">{
                        dst = "::0/0"
                }</span>
                <span class="cov8" title="1">routes = append(routes, map[string]string{
                        "dst": dst,
                        "gw":  g.String(),
                })</span>
        }
        <span class="cov8" title="1">result["routes"] = routes

        return result, nil</span>
}

func addDefaultGWResult020(result map[string]interface{}, gw []net.IP) (map[string]interface{}, error) <span class="cov8" title="1">{
        for _, g := range gw </span><span class="cov8" title="1">{
                if g.To4() != nil </span><span class="cov8" title="1">{
                        _, ok := result["ip4"]
                        if ok </span><span class="cov8" title="1">{
                                ip4, ok := result["ip4"].(map[string]interface{})
                                if !ok </span><span class="cov0" title="0">{
                                        return nil, fmt.Errorf("wrong ip4 format: %v", result["ip4"])
                                }</span>
                                <span class="cov8" title="1">routes := []interface{}{}
                                _, ok = ip4["routes"]
                                if ok </span><span class="cov8" title="1">{
                                        routes, ok = ip4["routes"].([]interface{})
                                        if !ok </span><span class="cov0" title="0">{
                                                return nil, fmt.Errorf("wrong ip4 routes format: %v", ip4["routes"])
                                        }</span>
                                }
                                <span class="cov8" title="1">ip4["routes"] = append(routes, map[string]string{
                                        "dst": "0.0.0.0/0",
                                        "gw":  g.String(),
                                })</span>
                        }
                } else<span class="cov8" title="1"> {
                        _, ok := result["ip6"]
                        if ok </span><span class="cov8" title="1">{
                                ip6, ok := result["ip6"].(map[string]interface{})
                                if !ok </span><span class="cov0" title="0">{
                                        return nil, fmt.Errorf("wrong ip6 format: %v", result["ip4"])
                                }</span>
                                <span class="cov8" title="1">routes := []interface{}{}
                                _, ok = ip6["routes"]
                                if ok </span><span class="cov8" title="1">{
                                        routes, ok = ip6["routes"].([]interface{})
                                        if !ok </span><span class="cov0" title="0">{
                                                return nil, fmt.Errorf("wrong ip6 routes format: %v", ip6["routes"])
                                        }</span>
                                }
                                <span class="cov8" title="1">ip6["routes"] = append(routes, map[string]string{
                                        "dst": "::/0",
                                        "gw":  g.String(),
                                })</span>
                        }
                }
        }
        <span class="cov8" title="1">return result, nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">// Copyright (c) 2021 Multus Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

package config

import (
        "encoding/json"
        "errors"
        "fmt"
        "io/ioutil"
        "path/filepath"
        "sort"
        "strings"
        "time"

        "github.com/blang/semver"
)

const (
        configListCapabilityKey   = "plugins"
        singleConfigCapabilityKey = "capabilities"
)

// LogOptionFunc mutates the `LoggingOptions` object
type LogOptionFunc func(logOptions *LogOptions)

// Option mutates the `conf` object
type Option func(conf *MultusConf) error

// MultusConf holds the multus configuration, and persists it to disk
type MultusConf struct {
        BinDir                   string          `json:"binDir,omitempty"`
        Capabilities             map[string]bool `json:"capabilities,omitempty"`
        CNIVersion               string          `json:"cniVersion"`
        LogFile                  string          `json:"logFile,omitempty"`
        LogLevel                 string          `json:"logLevel,omitempty"`
        LogToStderr              bool            `json:"logToStderr,omitempty"`
        LogOptions               *LogOptions     `json:"logOptions,omitempty"`
        Name                     string          `json:"name"`
        ClusterNetwork           string          `json:"clusterNetwork,omitempty"`
        NamespaceIsolation       bool            `json:"namespaceIsolation,omitempty"`
        RawNonIsolatedNamespaces string          `json:"globalNamespaces,omitempty"`
        ReadinessIndicatorFile   string          `json:"readinessindicatorfile,omitempty"`
        Type                     string          `json:"type"`
        CniDir                   string          `json:"cniDir,omitempty"`
}

// LogOptions specifies the configuration of the log
type LogOptions struct {
        MaxAge     *int  `json:"maxAge,omitempty"`
        MaxSize    *int  `json:"maxSize,omitempty"`
        MaxBackups *int  `json:"maxBackups,omitempty"`
        Compress   *bool `json:"compress,omitempty"`
}

// NewMultusConfig creates a basic configuration generator. It can be mutated
// via the `With...` methods.
func NewMultusConfig(pluginName string, cniVersion string, configurationOptions ...Option) (*MultusConf, error) <span class="cov8" title="1">{
        multusConfig := &amp;MultusConf{
                Name:         MultusDefaultNetworkName,
                CNIVersion:   cniVersion,
                Type:         pluginName,
                Capabilities: map[string]bool{},
        }

        err := multusConfig.Mutate(configurationOptions...)
        return multusConfig, err
}</span>

// CheckVersionCompatibility checks compatibilty of the
// top level cni version with the delegate cni version.
// Since version 0.4.0, CHECK was introduced, which
// causes incompatibility.
func CheckVersionCompatibility(mc *MultusConf, delegate interface{}) error <span class="cov8" title="1">{
        const versionFmt = "delegate cni version is %s while top level cni version is %s"
        v040, _ := semver.Make("0.4.0")
        multusCNIVersion, err := semver.Make(mc.CNIVersion)

        if err != nil </span><span class="cov0" title="0">{
                return errors.New("couldn't get top level cni version")
        }</span>

        <span class="cov8" title="1">if multusCNIVersion.GTE(v040) </span><span class="cov8" title="1">{
                delegatesMap, ok := delegate.(map[string]interface{})
                if !ok </span><span class="cov0" title="0">{
                        return errors.New("couldn't get cni version of delegate")
                }</span>
                <span class="cov8" title="1">delegateVersion, ok := delegatesMap["cniVersion"].(string)
                if !ok </span><span class="cov0" title="0">{
                        return errors.New("couldn't get cni version of delegate")
                }</span>
                <span class="cov8" title="1">v, err := semver.Make(delegateVersion)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if v.LT(v040) </span><span class="cov8" title="1">{
                        return fmt.Errorf(versionFmt, delegateVersion, mc.CNIVersion)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// Generate generates the multus configuration from whatever state is currently
// held
func (mc *MultusConf) Generate() (string, error) <span class="cov8" title="1">{
        data, err := json.Marshal(mc)
        return string(data), err
}</span>

// Mutate updates the MultusConf attributes according to the provided
// configuration `Option`s
func (mc *MultusConf) Mutate(configurationOptions ...Option) error <span class="cov8" title="1">{
        for _, configOption := range configurationOptions </span><span class="cov8" title="1">{
                err := configOption(mc)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// WithNamespaceIsolation mutates the inner state to enable the
// NamespaceIsolation attribute
func WithNamespaceIsolation() Option <span class="cov8" title="1">{
        return func(conf *MultusConf) error </span><span class="cov8" title="1">{
                conf.NamespaceIsolation = true
                return nil
        }</span>
}

// WithGlobalNamespaces mutates the inner state to set the
// RawNonIsolatedNamespaces attribute
func WithGlobalNamespaces(globalNamespaces string) Option <span class="cov8" title="1">{
        return func(conf *MultusConf) error </span><span class="cov8" title="1">{
                conf.RawNonIsolatedNamespaces = globalNamespaces
                return nil
        }</span>
}

// WithLogToStdErr mutates the inner state to enable the
// WithLogToStdErr attribute
func WithLogToStdErr() Option <span class="cov8" title="1">{
        return func(conf *MultusConf) error </span><span class="cov8" title="1">{
                conf.LogToStderr = true
                return nil
        }</span>
}

// WithLogLevel mutates the inner state to set the
// LogLevel attribute
func WithLogLevel(logLevel string) Option <span class="cov8" title="1">{
        return func(conf *MultusConf) error </span><span class="cov8" title="1">{
                conf.LogLevel = logLevel
                return nil
        }</span>
}

// WithLogFile mutates the inner state to set the
// logFile attribute
func WithLogFile(logFile string) Option <span class="cov8" title="1">{
        return func(conf *MultusConf) error </span><span class="cov8" title="1">{
                conf.LogFile = logFile
                return nil
        }</span>
}

// WithLogOptions mutates the inner state to set the
// LogOptions attribute
func WithLogOptions(logOptions *LogOptions) Option <span class="cov8" title="1">{
        return func(conf *MultusConf) error </span><span class="cov8" title="1">{
                conf.LogOptions = logOptions
                return nil
        }</span>
}

// WithReadinessFileIndicator mutates the inner state to set the
// ReadinessIndicatorFile attribute
func WithReadinessFileIndicator(path string) Option <span class="cov8" title="1">{
        return func(conf *MultusConf) error </span><span class="cov8" title="1">{
                conf.ReadinessIndicatorFile = path
                return nil
        }</span>
}

// WithAdditionalBinaryFileDir mutates the inner state to set the
// BinDir attribute
func WithAdditionalBinaryFileDir(directoryPath string) Option <span class="cov8" title="1">{
        return func(conf *MultusConf) error </span><span class="cov8" title="1">{
                conf.BinDir = directoryPath
                return nil
        }</span>
}

// WithOverriddenName mutates the inner state to set the
// Name attribute
func WithOverriddenName(networkName string) Option <span class="cov8" title="1">{
        return func(conf *MultusConf) error </span><span class="cov8" title="1">{
                conf.Name = networkName
                return nil
        }</span>
}

// WithCniDir mutates the inner state to set the
// multus CNI cache directory
func WithCniDir(cniDir string) Option <span class="cov0" title="0">{
        return func(conf *MultusConf) error </span><span class="cov0" title="0">{
                conf.CniDir = cniDir
                return nil
        }</span>
}

func withClusterNetwork(clusterNetwork string) Option <span class="cov8" title="1">{
        return func(conf *MultusConf) error </span><span class="cov8" title="1">{
                conf.ClusterNetwork = clusterNetwork
                return nil
        }</span>
}

func withCapabilities(cniData interface{}) Option <span class="cov8" title="1">{
        var enabledCapabilities []string
        var pluginsList []interface{}
        cniDataMap, ok := cniData.(map[string]interface{})
        if ok </span><span class="cov8" title="1">{
                if pluginsListEntry, ok := cniDataMap[configListCapabilityKey]; ok </span><span class="cov8" title="1">{
                        pluginsList = pluginsListEntry.([]interface{})
                }</span>
        } else<span class="cov0" title="0"> {
                return func(conf *MultusConf) error </span><span class="cov0" title="0">{
                        return errors.New("couldn't get cni config from delegate")
                }</span>
        }

        <span class="cov8" title="1">if len(pluginsList) &gt; 0 </span><span class="cov8" title="1">{
                for _, pluginData := range pluginsList </span><span class="cov8" title="1">{
                        enabledCapabilities = append(
                                enabledCapabilities,
                                extractCapabilities(pluginData)...)
                }</span>
        } else<span class="cov8" title="1"> {
                enabledCapabilities = extractCapabilities(cniData)
        }</span>

        <span class="cov8" title="1">return func(conf *MultusConf) error </span><span class="cov8" title="1">{
                for _, capability := range enabledCapabilities </span><span class="cov8" title="1">{
                        conf.Capabilities[capability] = true
                }</span>
                <span class="cov8" title="1">return nil</span>
        }
}

// MutateLogOptions update the LoggingOptions of the MultusConf according
// to the provided configuration `loggingOptions`
func MutateLogOptions(logOption *LogOptions, logOptionFunc ...LogOptionFunc) <span class="cov8" title="1">{
        for _, loggingOption := range logOptionFunc </span><span class="cov8" title="1">{
                loggingOption(logOption)
        }</span>
}

// WithLogMaxSize mutates the inner state to set the
// logMaxSize attribute
func WithLogMaxSize(maxSize *int) LogOptionFunc <span class="cov8" title="1">{
        return func(logOptions *LogOptions) </span><span class="cov8" title="1">{
                logOptions.MaxSize = maxSize
        }</span>
}

// WithLogMaxAge mutates the inner state to set the
// logMaxAge attribute
func WithLogMaxAge(maxAge *int) LogOptionFunc <span class="cov8" title="1">{
        return func(logOptions *LogOptions) </span><span class="cov8" title="1">{
                logOptions.MaxAge = maxAge
        }</span>
}

// WithLogMaxBackups mutates the inner state to set the
// logMaxBackups attribute
func WithLogMaxBackups(maxBackups *int) LogOptionFunc <span class="cov8" title="1">{
        return func(logOptions *LogOptions) </span><span class="cov8" title="1">{
                logOptions.MaxBackups = maxBackups
        }</span>
}

// WithLogCompress mutates the inner state to set the
// logCompress attribute
func WithLogCompress(compress *bool) LogOptionFunc <span class="cov8" title="1">{
        return func(logOptions *LogOptions) </span><span class="cov8" title="1">{
                logOptions.Compress = compress
        }</span>
}

func extractCapabilities(capabilitiesInterface interface{}) []string <span class="cov8" title="1">{
        capabilitiesMap, ok := capabilitiesInterface.(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">capabilitiesMapEntry, ok := capabilitiesMap[singleConfigCapabilityKey]
        if !ok </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">capabilities, ok := capabilitiesMapEntry.(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">var enabledCapabilities []string
        if len(capabilities) &gt; 0 </span><span class="cov8" title="1">{
                for capName, isCapabilityEnabled := range capabilities </span><span class="cov8" title="1">{
                        if isCapabilityEnabled.(bool) </span><span class="cov8" title="1">{
                                enabledCapabilities = append(enabledCapabilities, capName)
                        }</span>
                }
        }
        <span class="cov8" title="1">return enabledCapabilities</span>
}

func findMasterPlugin(cniConfigDirPath string, remainingTries int) (string, error) <span class="cov8" title="1">{
        if remainingTries == 0 </span><span class="cov0" title="0">{
                return "", fmt.Errorf("could not find a plugin configuration in %s", cniConfigDirPath)
        }</span>
        <span class="cov8" title="1">var cniPluginConfigs []string
        files, err := ioutil.ReadDir(cniConfigDirPath)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("error when listing the CNI plugin configurations: %w", err)
        }</span>

        <span class="cov8" title="1">for _, file := range files </span><span class="cov8" title="1">{
                if strings.HasPrefix(file.Name(), "00-multus") </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">fileExtension := filepath.Ext(file.Name())
                if fileExtension == ".conf" || fileExtension == ".conflist" </span><span class="cov8" title="1">{
                        cniPluginConfigs = append(cniPluginConfigs, file.Name())
                }</span>
        }

        <span class="cov8" title="1">if len(cniPluginConfigs) == 0 </span><span class="cov0" title="0">{
                time.Sleep(time.Second)
                return findMasterPlugin(cniConfigDirPath, remainingTries-1)
        }</span>
        <span class="cov8" title="1">sort.Strings(cniPluginConfigs)
        return cniPluginConfigs[0], nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">// Copyright (c) 2021 Multus Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

package config

import (
        "encoding/json"
        "fmt"
        "io/ioutil"

        "github.com/fsnotify/fsnotify"

        "gopkg.in/k8snetworkplumbingwg/multus-cni.v3/pkg/logging"
)

// MultusDefaultNetworkName holds the default name of the multus network
const (
        multusConfigFileName     = "00-multus.conf"
        MultusDefaultNetworkName = "multus-cni-network"
        UserRWPermission         = 0600
)

// Manager monitors the configuration of the primary CNI plugin, and
// regenerates multus configuration whenever it gets updated.
type Manager struct {
        cniConfigData        map[string]interface{}
        configWatcher        *fsnotify.Watcher
        multusConfig         *MultusConf
        multusConfigDir      string
        multusConfigFilePath string
        primaryCNIConfigPath string
}

// NewManager returns a config manager object, configured to persist the
// configuration to `multusAutoconfigDir`. This constructor will auto-discover
// the primary CNI for which it will delegate.
func NewManager(config MultusConf, multusAutoconfigDir string, forceCNIVersion bool) (*Manager, error) <span class="cov0" title="0">{
        defaultCNIPluginName, err := getPrimaryCNIPluginName(multusAutoconfigDir)
        if err != nil </span><span class="cov0" title="0">{
                _ = logging.Errorf("failed to find the primary CNI plugin: %v", err)
                return nil, err
        }</span>
        <span class="cov0" title="0">return newManager(config, multusAutoconfigDir, defaultCNIPluginName, forceCNIVersion)</span>
}

// NewManagerWithExplicitPrimaryCNIPlugin returns a config manager object,
// configured to persist the configuration to `multusAutoconfigDir`. This
// constructor will use the primary CNI plugin indicated by the user, via the
// primaryCNIPluginName variable.
func NewManagerWithExplicitPrimaryCNIPlugin(config MultusConf, multusAutoconfigDir, primaryCNIPluginName string, forceCNIVersion bool) (*Manager, error) <span class="cov8" title="1">{
        return newManager(config, multusAutoconfigDir, primaryCNIPluginName, forceCNIVersion)
}</span>

// overrideCNIVersion overrides cniVersion in cniConfigFile, it should be used only in kind case
func overrideCNIVersion(cniConfigFile string, multusCNIVersion string) error <span class="cov8" title="1">{
        masterCNIConfigData, err := ioutil.ReadFile(cniConfigFile)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to read cni config %s: %v", cniConfigFile, err)
        }</span>

        <span class="cov8" title="1">var primaryCNIConfigData map[string]interface{}
        if err := json.Unmarshal(masterCNIConfigData, &amp;primaryCNIConfigData); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to unmarshall cni config %s: %w", cniConfigFile, err)
        }</span>

        <span class="cov8" title="1">primaryCNIConfigData["cniVersion"] = multusCNIVersion
        configBytes, err := json.Marshal(primaryCNIConfigData)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("couldn't update cluster network config: %v", err)
        }</span>

        <span class="cov8" title="1">err = ioutil.WriteFile(cniConfigFile, configBytes, 0644)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("couldn't update cluster network config: %v", err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func newManager(config MultusConf, multusConfigDir, defaultCNIPluginName string, forceCNIVersion bool) (*Manager, error) <span class="cov8" title="1">{
        if forceCNIVersion </span><span class="cov0" title="0">{
                overrideCNIVersion(cniPluginConfigFilePath(multusConfigDir, defaultCNIPluginName), config.CNIVersion)
        }</span>

        <span class="cov8" title="1">watcher, err := newWatcher(multusConfigDir)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if defaultCNIPluginName == fmt.Sprintf("%s/%s", multusConfigDir, multusConfigFileName) </span><span class="cov0" title="0">{
                return nil, logging.Errorf("cannot specify %s/%s to prevent recursive config load", multusConfigDir, multusConfigFileName)
        }</span>

        <span class="cov8" title="1">configManager := &amp;Manager{
                configWatcher:        watcher,
                multusConfig:         &amp;config,
                multusConfigDir:      multusConfigDir,
                multusConfigFilePath: cniPluginConfigFilePath(multusConfigDir, multusConfigFileName),
                primaryCNIConfigPath: cniPluginConfigFilePath(multusConfigDir, defaultCNIPluginName),
        }

        if err := configManager.loadPrimaryCNIConfigFromFile(); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to load the primary CNI configuration as a multus delegate with error '%v'", err)
        }</span>

        <span class="cov8" title="1">return configManager, nil</span>
}

func (m *Manager) loadPrimaryCNIConfigFromFile() error <span class="cov8" title="1">{
        primaryCNIConfigData, err := primaryCNIData(m.primaryCNIConfigPath)
        if err != nil </span><span class="cov0" title="0">{
                return logging.Errorf("failed to access the primary CNI configuration from %s: %v", m.primaryCNIConfigPath, err)
        }</span>

        <span class="cov8" title="1">if err = CheckVersionCompatibility(m.multusConfig, primaryCNIConfigData); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return m.loadPrimaryCNIConfigurationData(primaryCNIConfigData)</span>
}

// OverrideNetworkName overrides the name of the multus configuration with the
// name of the delegated primary CNI.
func (m *Manager) OverrideNetworkName() error <span class="cov8" title="1">{
        name, ok := m.cniConfigData["name"]
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to access delegate CNI plugin name")
        }</span>
        <span class="cov8" title="1">networkName := name.(string)

        if networkName == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("the primary CNI Configuration does not feature the network name: %v", m.cniConfigData)
        }</span>
        <span class="cov8" title="1">return m.multusConfig.Mutate(WithOverriddenName(networkName))</span>
}

func (m *Manager) loadPrimaryCNIConfigurationData(primaryCNIConfigData interface{}) error <span class="cov8" title="1">{
        cniConfigData := primaryCNIConfigData.(map[string]interface{})

        m.cniConfigData = cniConfigData
        return m.multusConfig.Mutate(
                withClusterNetwork(m.primaryCNIConfigPath),
                withCapabilities(cniConfigData))
}</span>

// GenerateConfig generates a multus configuration from its current state
func (m Manager) GenerateConfig() (string, error) <span class="cov8" title="1">{
        if err := m.loadPrimaryCNIConfigFromFile(); err != nil </span><span class="cov0" title="0">{
                _ = logging.Errorf("failed to read the primary CNI plugin config from %s", m.primaryCNIConfigPath)
                return "", nil
        }</span>
        <span class="cov8" title="1">return m.multusConfig.Generate()</span>
}

// MonitorPluginConfiguration monitors the configuration file pointed
// to by the primaryCNIPluginName attribute, and re-generates the multus
// configuration whenever the primary CNI config is updated.
func (m Manager) MonitorPluginConfiguration(shutDown chan struct{}, done chan struct{}) error <span class="cov8" title="1">{
        logging.Verbosef("started to watch file %s", m.primaryCNIConfigPath)

        for </span><span class="cov8" title="1">{
                select </span>{
                case event := &lt;-m.configWatcher.Events:<span class="cov8" title="1">
                        // we're watching the DIR where the config sits, and the event
                        // does not concern the primary CNI config. Skip it.
                        if event.Name != m.primaryCNIConfigPath </span><span class="cov8" title="1">{
                                logging.Debugf("skipping un-related event %v", event)
                                continue</span>
                        }
                        <span class="cov8" title="1">logging.Debugf("process event: %v", event)

                        if !shouldRegenerateConfig(event) </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov8" title="1">updatedConfig, err := m.GenerateConfig()
                        if err != nil </span><span class="cov0" title="0">{
                                _ = logging.Errorf("failed to regenerate the multus configuration: %v", err)
                        }</span>

                        <span class="cov8" title="1">logging.Debugf("Re-generated MultusCNI config: %s", updatedConfig)
                        if err := m.PersistMultusConfig(updatedConfig); err != nil </span><span class="cov0" title="0">{
                                _ = logging.Errorf("failed to persist the multus configuration: %v", err)
                        }</span>
                        <span class="cov8" title="1">if err := m.loadPrimaryCNIConfigFromFile(); err != nil </span><span class="cov0" title="0">{
                                _ = logging.Errorf("failed to reload the updated config: %v", err)
                        }</span>

                case err := &lt;-m.configWatcher.Errors:<span class="cov0" title="0">
                        if err == nil </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">logging.Errorf("CNI monitoring error %v", err)</span>

                case &lt;-shutDown:<span class="cov8" title="1">
                        logging.Verbosef("Stopped monitoring, closing channel ...")
                        _ = m.configWatcher.Close()
                        done &lt;- struct{}{}
                        return nil</span>
                }
        }
}

// PersistMultusConfig persists the provided configuration to the disc, with
// Read / Write permissions. The output file path is `&lt;multus auto config dir&gt;/00-multus.conf`
func (m Manager) PersistMultusConfig(config string) error <span class="cov8" title="1">{
        return ioutil.WriteFile(m.multusConfigFilePath, []byte(config), UserRWPermission)
}</span>

func getPrimaryCNIPluginName(multusAutoconfigDir string) (string, error) <span class="cov8" title="1">{
        masterCniConfigFileName, err := findMasterPlugin(multusAutoconfigDir, 120)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to find the cluster master CNI plugin: %w", err)
        }</span>
        <span class="cov8" title="1">return masterCniConfigFileName, nil</span>
}

func cniPluginConfigFilePath(cniConfigDir string, cniConfigFileName string) string <span class="cov8" title="1">{
        return cniConfigDir + fmt.Sprintf("/%s", cniConfigFileName)
}</span>

func newWatcher(cniConfigDir string) (*fsnotify.Watcher, error) <span class="cov8" title="1">{
        watcher, err := fsnotify.NewWatcher()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create new watcher for %q: %v", cniConfigDir, err)
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                // Close watcher on error
                if err != nil </span><span class="cov0" title="0">{
                        watcher.Close()
                }</span>
        }()

        <span class="cov8" title="1">if err = watcher.Add(cniConfigDir); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to add watch on %q: %v", cniConfigDir, err)
        }</span>

        <span class="cov8" title="1">return watcher, nil</span>
}

func shouldRegenerateConfig(event fsnotify.Event) bool <span class="cov8" title="1">{
        return event.Op&amp;fsnotify.Write == fsnotify.Write ||
                event.Op&amp;fsnotify.Create == fsnotify.Create
}</span>

func primaryCNIData(masterCNIPluginPath string) (interface{}, error) <span class="cov8" title="1">{
        masterCNIConfigData, err := ioutil.ReadFile(masterCNIPluginPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read the cluster primary CNI config %s: %w", masterCNIPluginPath, err)
        }</span>

        <span class="cov8" title="1">var cniData interface{}
        if err := json.Unmarshal(masterCNIConfigData, &amp;cniData); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshall primary CNI config: %w", err)
        }</span>
        <span class="cov8" title="1">return cniData, nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">// Copyright (c) 2021 Multus Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package server

import (
        "bytes"
        "context"
        "encoding/json"
        "fmt"
        "io"
        "os"
        "os/exec"
        "strings"
        "sync"
        "syscall"
        "time"

        "github.com/containernetworking/cni/pkg/invoke"
        "github.com/containernetworking/cni/pkg/types"
        "github.com/containernetworking/cni/pkg/version"
)

// ChrootExec implements invoke.Exec to execute CNI with chroot
type ChrootExec struct {
        Stderr     io.Writer
        chrootDir  string
        workingDir string   // working directory in the outer root
        outerRoot  *os.File // outer root directory
        version.PluginDecoder
        mu sync.Mutex
}

var _ invoke.Exec = &amp;ChrootExec{}

func (e *ChrootExec) chroot() error <span class="cov8" title="1">{
        var err error
        e.workingDir, err = os.Getwd()
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "getwd before chroot failed: %v\n", err)
                return fmt.Errorf("getwd before chroot failed: %v", err)
        }</span>

        <span class="cov8" title="1">e.outerRoot, err = os.Open("/")
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "getwd before chroot failed: %v\n", err)
                return fmt.Errorf("getwd before chroot failed: %v", err)
        }</span>

        <span class="cov8" title="1">if err := syscall.Chroot(e.chrootDir); err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "chroot to %s failed: %v\n", e.chrootDir, err)
                return fmt.Errorf("chroot to %s failed: %v", e.chrootDir, err)
        }</span>

        <span class="cov8" title="1">if err := os.Chdir("/"); err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "chdir to \"/\" failed: %v\n", err)
                return fmt.Errorf("chdir to \"/\" failed: %v", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (e *ChrootExec) escape() error <span class="cov8" title="1">{
        if e.outerRoot == nil || e.workingDir == "" </span><span class="cov0" title="0">{
                return nil
        }</span>

        // change directory to outer root and close it
        <span class="cov8" title="1">if err := syscall.Fchdir(int(e.outerRoot.Fd())); err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "changing directory to outer root failed: %v\n", err)
                return fmt.Errorf("changing directory to outer root failed: %v", err)
        }</span>

        <span class="cov8" title="1">if err := e.outerRoot.Close(); err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "closing outer root failed: %v\n", err)
                return fmt.Errorf("closing outer root failed: %v", err)
        }</span>

        // chroot to current directory aka "." being the outer root
        <span class="cov8" title="1">if err := syscall.Chroot("."); err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "chroot to current directory failed: %v\n", err)
                return fmt.Errorf("chroot to current directory failed: %v", err)
        }</span>

        <span class="cov8" title="1">if err := os.Chdir(e.workingDir); err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "chdir to working directory failed: %v\n", err)
                return fmt.Errorf("chdir to working directory failed: %v", err)
        }</span>
        <span class="cov8" title="1">e.outerRoot = nil
        e.workingDir = ""

        return nil</span>
}

// ExecPlugin executes CNI plugin with given environment/stdin data.
func (e *ChrootExec) ExecPlugin(ctx context.Context, pluginPath string, stdinData []byte, environ []string) ([]byte, error) <span class="cov8" title="1">{
        // lock and do chroot to execute plugin with host root
        e.mu.Lock()
        defer e.mu.Unlock()
        err := e.chroot()
        defer e.escape()

        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "ExecPlugin failed at chroot: %v\n", err)
                return nil, fmt.Errorf("ExecPlugin failed at chroot: %v", err)
        }</span>

        <span class="cov8" title="1">stdout := &amp;bytes.Buffer{}
        stderr := &amp;bytes.Buffer{}
        c := exec.CommandContext(ctx, pluginPath)
        c.Env = environ
        c.Stdin = bytes.NewBuffer(stdinData)
        c.Stdout = stdout
        c.Stderr = stderr

        // Retry the command on "text file busy" errors
        for i := 0; i &lt;= 5; i++ </span><span class="cov8" title="1">{
                err = c.Run()

                // Command succeeded
                if err == nil </span><span class="cov8" title="1">{
                        break</span>
                }

                // If the plugin is currently about to be written, then we wait a
                // second and try it again
                <span class="cov8" title="1">if strings.Contains(err.Error(), "text file busy") </span><span class="cov0" title="0">{
                        time.Sleep(time.Second)
                        continue</span>
                }

                // All other errors except than the busy text file
                <span class="cov8" title="1">return nil, e.pluginErr(err, stdout.Bytes(), stderr.Bytes())</span>
        }

        // Copy stderr to caller's buffer in case plugin printed to both
        // stdout and stderr for some reason. Ignore failures as stderr is
        // only informational.
        <span class="cov8" title="1">if e.Stderr != nil &amp;&amp; stderr.Len() &gt; 0 </span><span class="cov0" title="0">{
                _, _ = stderr.WriteTo(e.Stderr)
        }</span>
        <span class="cov8" title="1">return stdout.Bytes(), nil</span>
}

func (e *ChrootExec) pluginErr(err error, stdout, stderr []byte) error <span class="cov8" title="1">{
        emsg := types.Error{}
        if len(stdout) == 0 </span><span class="cov8" title="1">{
                if len(stderr) == 0 </span><span class="cov8" title="1">{
                        emsg.Msg = fmt.Sprintf("netplugin failed with no error message: %v", err)
                }</span> else<span class="cov0" title="0"> {
                        emsg.Msg = fmt.Sprintf("netplugin failed: %q", string(stderr))
                }</span>
        } else<span class="cov0" title="0"> if perr := json.Unmarshal(stdout, &amp;emsg); perr != nil </span><span class="cov0" title="0">{
                emsg.Msg = fmt.Sprintf("netplugin failed but error parsing its diagnostic message %q: %v", string(stdout), perr)
        }</span>
        <span class="cov8" title="1">return &amp;emsg</span>
}

// FindInPath try to find CNI plugin based on given path
func (e *ChrootExec) FindInPath(plugin string, paths []string) (string, error) <span class="cov8" title="1">{
        e.mu.Lock()
        defer e.mu.Unlock()
        err := e.chroot()
        defer e.escape()
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "FindInPath failed at chroot: %v\n", err)
                return "", fmt.Errorf("FindInPath failed at chroot: %v", err)
        }</span>

        <span class="cov8" title="1">return invoke.FindInPath(plugin, paths)</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">// Copyright (c) 2021 Multus Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

package server

import (
        "bytes"
        "encoding/json"
        "fmt"
        "io/ioutil"
        "net"
        "net/http"
        "os"
        "strings"

        "github.com/containernetworking/cni/pkg/invoke"
        "github.com/containernetworking/cni/pkg/skel"
        cnitypes "github.com/containernetworking/cni/pkg/types"
        cni100 "github.com/containernetworking/cni/pkg/types/100"
        "github.com/gorilla/mux"

        k8s "gopkg.in/k8snetworkplumbingwg/multus-cni.v3/pkg/k8sclient"
        "gopkg.in/k8snetworkplumbingwg/multus-cni.v3/pkg/logging"
        "gopkg.in/k8snetworkplumbingwg/multus-cni.v3/pkg/multus"
        "gopkg.in/k8snetworkplumbingwg/multus-cni.v3/pkg/server/config"
        "gopkg.in/k8snetworkplumbingwg/multus-cni.v3/pkg/types"
)

// HandleCNIRequest is the CNI server handler function; it is invoked whenever
// a CNI request is processed.
func HandleCNIRequest(cmd string, k8sArgs *types.K8sArgs, cniCmdArgs *skel.CmdArgs, exec invoke.Exec, kubeClient *k8s.ClientInfo) ([]byte, error) <span class="cov8" title="1">{
        var result []byte
        var err error

        logging.Verbosef("%s starting CNI request %+v", cmd, cniCmdArgs)
        switch cmd </span>{
        case "ADD":<span class="cov8" title="1">
                result, err = cmdAdd(cniCmdArgs, k8sArgs, exec, kubeClient)</span>
        case "DEL":<span class="cov8" title="1">
                err = cmdDelete(cniCmdArgs, k8sArgs, exec, kubeClient)</span>
        case "CHECK":<span class="cov8" title="1">
                err = cmdCheck(cniCmdArgs, k8sArgs, exec, kubeClient)</span>
        default:<span class="cov0" title="0">
                return []byte(""), fmt.Errorf("unknown cmd type: %s", cmd)</span>
        }
        <span class="cov8" title="1">logging.Verbosef("%s finished CNI request %+v, result: %q, err: %v", cmd, *cniCmdArgs, string(result), err)
        if err != nil </span><span class="cov0" title="0">{
                // Prefix errors with request info for easier failure debugging
                return nil, fmt.Errorf("%+v ERRORED: %v", *cniCmdArgs, err)
        }</span>
        <span class="cov8" title="1">return result, nil</span>
}

// GetListener creates a listener to a unix socket located in `socketPath`
func GetListener(socketPath string) (net.Listener, error) <span class="cov8" title="1">{
        l, err := net.Listen("unix", socketPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, logging.Errorf("failed to listen on pod info socket: %v", err)
        }</span>
        <span class="cov8" title="1">if err := os.Chmod(socketPath, config.UserRWPermission); err != nil </span><span class="cov0" title="0">{
                _ = l.Close()
                return nil, logging.Errorf("failed to listen on pod info socket: %v", err)
        }</span>
        <span class="cov8" title="1">return l, nil</span>
}

// NewCNIServer creates and returns a new Server object which will listen on a socket in the given path
func NewCNIServer(daemonConfig *types.ControllerNetConf, serverConfig []byte) (*Server, error) <span class="cov0" title="0">{
        kubeClient, err := k8s.InClusterK8sClient()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error getting k8s client: %v", err)
        }</span>

        <span class="cov0" title="0">exec := invoke.Exec(nil)
        if daemonConfig.ChrootDir != "" </span><span class="cov0" title="0">{
                exec = &amp;ChrootExec{
                        Stderr:    os.Stderr,
                        chrootDir: daemonConfig.ChrootDir,
                }
                logging.Verbosef("server configured with chroot: %s", daemonConfig.ChrootDir)
        }</span>

        <span class="cov0" title="0">return newCNIServer(daemonConfig.MultusSocketDir, kubeClient, exec, serverConfig)</span>
}

func newCNIServer(rundir string, kubeClient *k8s.ClientInfo, exec invoke.Exec, servConfig []byte) (*Server, error) <span class="cov8" title="1">{

        // preprocess server config to be used to override multus CNI config
        // see extractCniData() for the detail
        if servConfig != nil </span><span class="cov8" title="1">{
                servConfig = bytes.Replace(servConfig, []byte("{"), []byte(","), 1)
        }</span>

        <span class="cov8" title="1">router := mux.NewRouter()
        s := &amp;Server{
                Server: http.Server{
                        Handler: router,
                },
                rundir:       rundir,
                requestFunc:  HandleCNIRequest,
                kubeclient:   kubeClient,
                exec:         exec,
                serverConfig: servConfig,
        }

        router.NotFoundHandler = http.HandlerFunc(http.NotFound)
        router.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                result, err := s.handleCNIRequest(r)
                if err != nil </span><span class="cov0" title="0">{
                        http.Error(w, fmt.Sprintf("%v", err), http.StatusBadRequest)
                        return
                }</span>

                // Empty response JSON means success with no body
                <span class="cov8" title="1">w.Header().Set("Content-Type", "application/json")
                if _, err := w.Write(result); err != nil </span><span class="cov0" title="0">{
                        _ = logging.Errorf("Error writing HTTP response: %v", err)
                }</span>
        }).Methods("POST")

        <span class="cov8" title="1">return s, nil</span>
}

func (s *Server) handleCNIRequest(r *http.Request) ([]byte, error) <span class="cov8" title="1">{
        var cr Request
        b, err := ioutil.ReadAll(r.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if err := json.Unmarshal(b, &amp;cr); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">cmdType, cniCmdArgs, err := extractCniData(&amp;cr, s.serverConfig)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("could not extract the CNI command args: %w", err)
        }</span>

        <span class="cov8" title="1">k8sArgs, err := kubernetesRuntimeArgs(cr.Env, s.kubeclient)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("could not extract the kubernetes runtime args: %w", err)
        }</span>

        <span class="cov8" title="1">result, err := s.requestFunc(cmdType, k8sArgs, cniCmdArgs, s.exec, s.kubeclient)
        if err != nil </span><span class="cov0" title="0">{
                // Prefix error with request information for easier debugging
                return nil, fmt.Errorf("%+v %v", cniCmdArgs, err)
        }</span>
        <span class="cov8" title="1">return result, nil</span>
}

func extractCniData(cniRequest *Request, overrideConf []byte) (string, *skel.CmdArgs, error) <span class="cov8" title="1">{
        cmd, ok := cniRequest.Env["CNI_COMMAND"]
        if !ok </span><span class="cov0" title="0">{
                return "", nil, fmt.Errorf("unexpected or missing CNI_COMMAND")
        }</span>

        <span class="cov8" title="1">cniCmdArgs := &amp;skel.CmdArgs{}
        cniCmdArgs.ContainerID, ok = cniRequest.Env["CNI_CONTAINERID"]
        if !ok </span><span class="cov0" title="0">{
                return "", nil, fmt.Errorf("missing CNI_CONTAINERID")
        }</span>
        <span class="cov8" title="1">cniCmdArgs.Netns, ok = cniRequest.Env["CNI_NETNS"]
        if !ok </span><span class="cov0" title="0">{
                return "", nil, fmt.Errorf("missing CNI_NETNS")
        }</span>

        <span class="cov8" title="1">cniCmdArgs.IfName, ok = cniRequest.Env["CNI_IFNAME"]
        if !ok </span><span class="cov8" title="1">{
                cniCmdArgs.IfName = "eth0"
        }</span>

        <span class="cov8" title="1">cniArgs, found := cniRequest.Env["CNI_ARGS"]
        if !found </span><span class="cov0" title="0">{
                return "", nil, fmt.Errorf("missing CNI_ARGS")
        }</span>
        <span class="cov8" title="1">cniCmdArgs.Args = cniArgs

        if overrideConf != nil </span><span class="cov8" title="1">{
                // trim the close bracket from multus CNI config and put the server config
                // to override CNI config with server config.
                // note: if there are two or more value in same key, then the
                // latest one is used at golang json implementation
                idx := bytes.LastIndex(cniRequest.Config, []byte("}"))
                if idx == -1 </span><span class="cov0" title="0">{
                        return "", nil, fmt.Errorf("invalid CNI config")
                }</span>
                <span class="cov8" title="1">cniCmdArgs.StdinData = append(cniRequest.Config[:idx], overrideConf...)</span>
        } else<span class="cov8" title="1"> {
                cniCmdArgs.StdinData = cniRequest.Config
        }</span>

        <span class="cov8" title="1">return cmd, cniCmdArgs, nil</span>
}

func kubernetesRuntimeArgs(cniRequestEnvVariables map[string]string, kubeClient *k8s.ClientInfo) (*types.K8sArgs, error) <span class="cov8" title="1">{
        cniEnv, err := gatherCNIArgs(cniRequestEnvVariables)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">podNamespace, found := cniEnv["K8S_POD_NAMESPACE"]
        if !found </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("missing K8S_POD_NAMESPACE")
        }</span>

        <span class="cov8" title="1">podName, found := cniEnv["K8S_POD_NAME"]
        if !found </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("missing K8S_POD_NAME")
        }</span>

        <span class="cov8" title="1">uid, err := podUID(kubeClient, cniEnv, podNamespace, podName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">sandboxID := cniRequestEnvVariables["K8S_POD_INFRA_CONTAINER_ID"]

        return &amp;types.K8sArgs{
                K8S_POD_NAME:               cnitypes.UnmarshallableString(podName),
                K8S_POD_NAMESPACE:          cnitypes.UnmarshallableString(podNamespace),
                K8S_POD_INFRA_CONTAINER_ID: cnitypes.UnmarshallableString(sandboxID),
                K8S_POD_UID:                cnitypes.UnmarshallableString(uid),
        }, nil</span>
}

func gatherCNIArgs(env map[string]string) (map[string]string, error) <span class="cov8" title="1">{
        cniArgs, ok := env["CNI_ARGS"]
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("missing CNI_ARGS: '%s'", env)
        }</span>

        <span class="cov8" title="1">mapArgs := make(map[string]string)
        for _, arg := range strings.Split(cniArgs, ";") </span><span class="cov8" title="1">{
                parts := strings.Split(arg, "=")
                if len(parts) != 2 </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("invalid CNI_ARG '%s'", arg)
                }</span>
                <span class="cov8" title="1">mapArgs[strings.TrimSpace(parts[0])] = strings.TrimSpace(parts[1])</span>
        }
        <span class="cov8" title="1">return mapArgs, nil</span>
}
func podUID(kubeclient *k8s.ClientInfo, cniArgs map[string]string, podNamespace, podName string) (string, error) <span class="cov8" title="1">{
        // UID may not be passed by all runtimes yet. Will be passed
        // by CRIO 1.20+ and containerd 1.5+ soon.
        // CRIO 1.20: https://github.com/cri-o/cri-o/pull/5029
        // CRIO 1.21: https://github.com/cri-o/cri-o/pull/5028
        // CRIO 1.22: https://github.com/cri-o/cri-o/pull/5026
        // containerd 1.6: https://github.com/containerd/containerd/pull/5640
        // containerd 1.5: https://github.com/containerd/containerd/pull/5643
        uid, found := cniArgs["K8S_POD_UID"]
        if !found </span><span class="cov0" title="0">{
                pod, err := kubeclient.GetPod(podNamespace, podName)
                if err != nil </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("missing pod UID; attempted to recover it from the K8s API, but failed: %w", err)
                }</span>
                <span class="cov0" title="0">return string(pod.UID), nil</span>
        }

        <span class="cov8" title="1">return uid, nil</span>
}

func cmdAdd(cmdArgs *skel.CmdArgs, k8sArgs *types.K8sArgs, exec invoke.Exec, kubeClient *k8s.ClientInfo) ([]byte, error) <span class="cov8" title="1">{
        namespace := string(k8sArgs.K8S_POD_NAMESPACE)
        podName := string(k8sArgs.K8S_POD_NAME)
        if namespace == "" || podName == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("required CNI variable missing. pod name: %s; pod namespace: %s", podName, namespace)
        }</span>

        <span class="cov8" title="1">logging.Debugf("CmdAdd for [%s/%s]. CNI conf: %+v", namespace, podName, *cmdArgs)
        result, err := multus.CmdAdd(cmdArgs, exec, kubeClient)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error configuring pod [%s/%s] networking: %v", namespace, podName, err)
        }</span>
        <span class="cov8" title="1">return serializeResult(result)</span>
}

func cmdDelete(cmdArgs *skel.CmdArgs, k8sArgs *types.K8sArgs, exec invoke.Exec, kubeClient *k8s.ClientInfo) error <span class="cov8" title="1">{
        namespace := string(k8sArgs.K8S_POD_NAMESPACE)
        podName := string(k8sArgs.K8S_POD_NAME)
        if namespace == "" || podName == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("required CNI variable missing. pod name: %s; pod namespace: %s", podName, namespace)
        }</span>

        <span class="cov8" title="1">logging.Debugf("CmdDel for [%s/%s]. CNI conf: %+v", namespace, podName, *cmdArgs)
        return multus.CmdDel(cmdArgs, exec, kubeClient)</span>
}

func cmdCheck(cmdArgs *skel.CmdArgs, k8sArgs *types.K8sArgs, exec invoke.Exec, kubeClient *k8s.ClientInfo) error <span class="cov8" title="1">{
        namespace := string(k8sArgs.K8S_POD_NAMESPACE)
        podName := string(k8sArgs.K8S_POD_NAME)
        if namespace == "" || podName == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("required CNI variable missing. pod name: %s; pod namespace: %s", podName, namespace)
        }</span>

        <span class="cov8" title="1">logging.Debugf("CmdCheck for [%s/%s]. CNI conf: %+v", namespace, podName, *cmdArgs)
        return multus.CmdCheck(cmdArgs, exec, kubeClient)</span>
}

func serializeResult(result cnitypes.Result) ([]byte, error) <span class="cov8" title="1">{
        // cni result is converted to latest here and decoded to specific cni version at multus-shim
        realResult, err := cni100.NewResultFromResult(result)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to generate the CNI result: %w", err)
        }</span>

        <span class="cov8" title="1">responseBytes, err := json.Marshal(&amp;Response{Result: realResult})
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to marshal pod request response: %v", err)
        }</span>
        <span class="cov8" title="1">return responseBytes, nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package server

import (
        "bytes"
        "encoding/json"
        "fmt"
        "io/ioutil"
        "net"
        "net/http"
        "os"
        "strings"

        "github.com/containernetworking/cni/pkg/skel"
        cnitypes "github.com/containernetworking/cni/pkg/types"

        "gopkg.in/k8snetworkplumbingwg/multus-cni.v3/pkg/logging"
        "gopkg.in/k8snetworkplumbingwg/multus-cni.v3/pkg/types"
)

const (
        defaultMultusRunDir = "/run/multus/"
)

// CmdAdd implements the CNI spec ADD command handler
func CmdAdd(args *skel.CmdArgs) error <span class="cov8" title="1">{
        response, cniVersion, err := postRequest(args, true)
        if err != nil </span><span class="cov0" title="0">{
                logging.Errorf("CmdAdd (shim): %v", err)
                return err
        }</span>

        <span class="cov8" title="1">logging.Verbosef("CmdAdd (shim): %v", *response.Result)
        return cnitypes.PrintResult(response.Result, cniVersion)</span>
}

// CmdCheck implements the CNI spec CHECK command handler
func CmdCheck(args *skel.CmdArgs) error <span class="cov8" title="1">{
        _, _, err := postRequest(args, false)
        if err != nil </span><span class="cov0" title="0">{
                logging.Errorf("CmdCheck (shim): %v", err)
                return err
        }</span>

        <span class="cov8" title="1">return err</span>
}

// CmdDel implements the CNI spec DEL command handler
func CmdDel(args *skel.CmdArgs) error <span class="cov8" title="1">{
        _, _, err := postRequest(args, false)
        if err != nil </span><span class="cov0" title="0">{
                logging.Errorf("CmdDel (shim): %v", err)
                return nil
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func postRequest(args *skel.CmdArgs, expectReply bool) (*Response, string, error) <span class="cov8" title="1">{
        multusShimConfig, err := shimConfig(args.StdinData)
        if err != nil </span><span class="cov0" title="0">{
                return nil, "", fmt.Errorf("invalid CNI configuration passed to multus-shim: %w", err)
        }</span>

        <span class="cov8" title="1">cniRequest, err := newCNIRequest(args)
        if err != nil </span><span class="cov0" title="0">{
                return nil, multusShimConfig.CNIVersion, err
        }</span>

        <span class="cov8" title="1">body, err := DoCNI("http://dummy/", cniRequest, SocketPath(multusShimConfig.MultusSocketDir))
        if err != nil </span><span class="cov0" title="0">{
                return nil, multusShimConfig.CNIVersion, err
        }</span>

        <span class="cov8" title="1">response := &amp;Response{}
        if expectReply </span><span class="cov8" title="1">{
                if err = json.Unmarshal(body, response); err != nil </span><span class="cov0" title="0">{
                        err = fmt.Errorf("failed to unmarshal response '%s': %v", string(body), err)
                        return nil, multusShimConfig.CNIVersion, err
                }</span>
        }
        <span class="cov8" title="1">return response, multusShimConfig.CNIVersion, nil</span>
}

// Create and fill a Request with this Plugin's environment and stdin which
// contain the CNI variables and configuration
func newCNIRequest(args *skel.CmdArgs) (*Request, error) <span class="cov8" title="1">{
        envMap := make(map[string]string)
        for _, item := range os.Environ() </span><span class="cov8" title="1">{
                idx := strings.Index(item, "=")
                if idx &gt; 0 </span><span class="cov8" title="1">{
                        envMap[strings.TrimSpace(item[:idx])] = item[idx+1:]
                }</span>
        }

        <span class="cov8" title="1">return &amp;Request{
                Env:    envMap,
                Config: args.StdinData,
        }, nil</span>
}

func shimConfig(cniConfig []byte) (*types.ShimNetConf, error) <span class="cov8" title="1">{
        multusConfig := &amp;types.ShimNetConf{}
        if err := json.Unmarshal(cniConfig, multusConfig); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to gather the multus configuration: %w", err)
        }</span>
        <span class="cov8" title="1">if multusConfig.MultusSocketDir == "" </span><span class="cov0" title="0">{
                multusConfig.MultusSocketDir = defaultMultusRunDir
        }</span>
        // Logging
        <span class="cov8" title="1">logging.SetLogStderr(multusConfig.LogToStderr)
        if multusConfig.LogFile != "" </span><span class="cov0" title="0">{
                logging.SetLogFile(multusConfig.LogFile)
        }</span>
        <span class="cov8" title="1">if multusConfig.LogLevel != "" </span><span class="cov0" title="0">{
                logging.SetLogLevel(multusConfig.LogLevel)
        }</span>
        <span class="cov8" title="1">return multusConfig, nil</span>
}

// DoCNI sends a CNI request to the CNI server via JSON + HTTP over a root-owned unix socket,
// and returns the result
func DoCNI(url string, req interface{}, socketPath string) ([]byte, error) <span class="cov8" title="1">{
        data, err := json.Marshal(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to marshal CNI request %v: %v", req, err)
        }</span>

        <span class="cov8" title="1">client := &amp;http.Client{
                Transport: &amp;http.Transport{
                        Dial: func(proto, addr string) (net.Conn, error) </span><span class="cov8" title="1">{
                                return net.Dial("unix", socketPath)
                        }</span>,
                },
        }

        <span class="cov8" title="1">resp, err := client.Post(url, "application/json", bytes.NewReader(data))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to send CNI request: %v", err)
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        body, err := ioutil.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read CNI result: %v", err)
        }</span>

        <span class="cov8" title="1">if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("CNI request failed with status %v: '%s'", resp.StatusCode, string(body))
        }</span>

        <span class="cov8" title="1">return body, nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">// Copyright (c) 2021 Multus Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

package server

import (
        "fmt"
        "os"
        "path/filepath"
)

const (
        serverSocketName                   = "multus.sock"
        fullReadWriteExecutePermissions    = 0777
        thickPluginSocketRunDirPermissions = 0700
)

// FilesystemPreRequirements ensures the target `rundir` features the correct
// permissions.
func FilesystemPreRequirements(rundir string) error <span class="cov8" title="1">{
        if err := os.RemoveAll(rundir); err != nil &amp;&amp; !os.IsNotExist(err) </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to remove old pod info socket directory %s: %v", rundir, err)
        }</span>
        <span class="cov8" title="1">if err := os.MkdirAll(rundir, thickPluginSocketRunDirPermissions); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create pod info socket directory %s: %v", rundir, err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// SocketPath returns the path of the multus CNI socket
func SocketPath(rundir string) string <span class="cov8" title="1">{
        return filepath.Join(rundir, serverSocketName)
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">// Copyright (c) 2017 Intel Corporation
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

package types

import (
        "encoding/json"
        "fmt"
        "io/ioutil"
        "net"
        "os"
        "strings"

        "github.com/containernetworking/cni/libcni"
        "github.com/containernetworking/cni/pkg/skel"
        cni100 "github.com/containernetworking/cni/pkg/types/100"
        "github.com/containernetworking/cni/pkg/version"
        nadutils "github.com/k8snetworkplumbingwg/network-attachment-definition-client/pkg/utils"
        "gopkg.in/k8snetworkplumbingwg/multus-cni.v3/pkg/logging"
)

const (
        defaultCNIDir                 = "/var/lib/cni/multus"
        defaultConfDir                = "/etc/cni/multus/net.d"
        defaultBinDir                 = "/opt/cni/bin"
        defaultReadinessIndicatorFile = ""
        defaultMultusNamespace        = "kube-system"
        defaultNonIsolatedNamespace   = "default"
)

// const block for multus-daemon configs
const (
        // DefaultMultusDaemonConfigFile is the default path of the config file
        DefaultMultusDaemonConfigFile = "/etc/cni/net.d/multus.d/daemon-config.json"
        defaultMultusRunDir           = "/run/multus/"
)

// LoadDelegateNetConfList reads DelegateNetConf from bytes
func LoadDelegateNetConfList(bytes []byte, delegateConf *DelegateNetConf) error <span class="cov8" title="1">{
        logging.Debugf("LoadDelegateNetConfList: %s, %v", string(bytes), delegateConf)

        if err := json.Unmarshal(bytes, &amp;delegateConf.ConfList); err != nil </span><span class="cov8" title="1">{
                return logging.Errorf("LoadDelegateNetConfList: error unmarshalling delegate conflist: %v", err)
        }</span>

        <span class="cov8" title="1">if delegateConf.ConfList.Plugins == nil </span><span class="cov8" title="1">{
                return logging.Errorf("LoadDelegateNetConfList: delegate must have the 'type' or 'plugin' field")
        }</span>

        <span class="cov8" title="1">if delegateConf.ConfList.Plugins[0].Type == "" </span><span class="cov0" title="0">{
                return logging.Errorf("LoadDelegateNetConfList: a plugin delegate must have the 'type' field")
        }</span>
        <span class="cov8" title="1">delegateConf.ConfListPlugin = true
        delegateConf.Name = delegateConf.ConfList.Name
        return nil</span>
}

// LoadDelegateNetConf converts raw CNI JSON into a DelegateNetConf structure
func LoadDelegateNetConf(bytes []byte, net *NetworkSelectionElement, deviceID string, resourceName string) (*DelegateNetConf, error) <span class="cov8" title="1">{
        var err error
        logging.Debugf("LoadDelegateNetConf: %s, %v, %s", string(bytes), net, deviceID)

        delegateConf := &amp;DelegateNetConf{}
        if err := json.Unmarshal(bytes, &amp;delegateConf.Conf); err != nil </span><span class="cov8" title="1">{
                return nil, logging.Errorf("LoadDelegateNetConf: error unmarshalling delegate config: %v", err)
        }</span>
        <span class="cov8" title="1">delegateConf.Name = delegateConf.Conf.Name

        // Do some minimal validation
        if delegateConf.Conf.Type == "" </span><span class="cov8" title="1">{
                if err := LoadDelegateNetConfList(bytes, delegateConf); err != nil </span><span class="cov8" title="1">{
                        return nil, logging.Errorf("LoadDelegateNetConf: failed with: %v", err)
                }</span>
                <span class="cov8" title="1">if deviceID != "" </span><span class="cov8" title="1">{
                        bytes, err = addDeviceIDInConfList(bytes, deviceID)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, logging.Errorf("LoadDelegateNetConf: failed to add deviceID in NetConfList bytes: %v", err)
                        }</span>
                }
                <span class="cov8" title="1">if net != nil &amp;&amp; net.CNIArgs != nil </span><span class="cov8" title="1">{
                        bytes, err = addCNIArgsInConfList(bytes, net.CNIArgs)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, logging.Errorf("LoadDelegateNetConf(): failed to add cni-args in NetConfList bytes: %v", err)
                        }</span>
                }
        } else<span class="cov8" title="1"> {
                if deviceID != "" </span><span class="cov8" title="1">{
                        bytes, err = delegateAddDeviceID(bytes, deviceID)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, logging.Errorf("LoadDelegateNetConf: failed to add deviceID in NetConf bytes: %v", err)
                        }</span>
                        // Save them for housekeeping
                        <span class="cov8" title="1">delegateConf.ResourceName = resourceName
                        delegateConf.DeviceID = deviceID</span>
                }
                <span class="cov8" title="1">if net != nil &amp;&amp; net.CNIArgs != nil </span><span class="cov8" title="1">{
                        bytes, err = addCNIArgsInConfig(bytes, net.CNIArgs)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, logging.Errorf("LoadDelegateNetConf(): failed to add cni-args in NetConfList bytes: %v", err)
                        }</span>
                }
        }

        <span class="cov8" title="1">if net != nil </span><span class="cov8" title="1">{
                if net.Name != "" </span><span class="cov8" title="1">{
                        // Overwrite CNI config name with net-attach-def name
                        delegateConf.Name = fmt.Sprintf("%s/%s", net.Namespace, net.Name)
                }</span>
                <span class="cov8" title="1">if net.InterfaceRequest != "" </span><span class="cov8" title="1">{
                        delegateConf.IfnameRequest = net.InterfaceRequest
                }</span>
                <span class="cov8" title="1">if net.MacRequest != "" </span><span class="cov8" title="1">{
                        delegateConf.MacRequest = net.MacRequest
                }</span>
                <span class="cov8" title="1">if net.IPRequest != nil </span><span class="cov8" title="1">{
                        delegateConf.IPRequest = net.IPRequest
                }</span>
                <span class="cov8" title="1">if net.BandwidthRequest != nil </span><span class="cov8" title="1">{
                        delegateConf.BandwidthRequest = net.BandwidthRequest
                }</span>
                <span class="cov8" title="1">if net.PortMappingsRequest != nil </span><span class="cov8" title="1">{
                        delegateConf.PortMappingsRequest = net.PortMappingsRequest
                }</span>
                <span class="cov8" title="1">if net.GatewayRequest != nil </span><span class="cov0" title="0">{
                        delegateConf.GatewayRequest = append(delegateConf.GatewayRequest, net.GatewayRequest...)
                }</span>
                <span class="cov8" title="1">if net.InfinibandGUIDRequest != "" </span><span class="cov8" title="1">{
                        delegateConf.InfinibandGUIDRequest = net.InfinibandGUIDRequest
                }</span>
                <span class="cov8" title="1">if net.DeviceID != "" </span><span class="cov0" title="0">{
                        if deviceID != "" </span><span class="cov0" title="0">{
                                logging.Debugf("Warning: Both RuntimeConfig and ResourceMap provide deviceID. Ignoring RuntimeConfig")
                        }</span> else<span class="cov0" title="0"> {
                                delegateConf.DeviceID = net.DeviceID
                        }</span>
                }
        }

        <span class="cov8" title="1">delegateConf.Bytes = bytes

        return delegateConf, nil</span>
}

// mergeCNIRuntimeConfig creates CNI runtimeconfig from delegate
func mergeCNIRuntimeConfig(runtimeConfig *RuntimeConfig, delegate *DelegateNetConf) *RuntimeConfig <span class="cov8" title="1">{
        logging.Debugf("mergeCNIRuntimeConfig: %v %v", runtimeConfig, delegate)
        var mergedRuntimeConfig RuntimeConfig

        if runtimeConfig == nil </span><span class="cov0" title="0">{
                mergedRuntimeConfig = RuntimeConfig{}
        }</span> else<span class="cov8" title="1"> {
                mergedRuntimeConfig = *runtimeConfig
        }</span>

        // multus inject RuntimeConfig only in case of non MasterPlugin.
        <span class="cov8" title="1">if delegate.MasterPlugin != true </span><span class="cov8" title="1">{
                logging.Debugf("mergeCNIRuntimeConfig: add runtimeConfig for net-attach-def: %v", mergedRuntimeConfig)
                if delegate.PortMappingsRequest != nil </span><span class="cov8" title="1">{
                        mergedRuntimeConfig.PortMaps = delegate.PortMappingsRequest
                }</span>
                <span class="cov8" title="1">if delegate.BandwidthRequest != nil </span><span class="cov8" title="1">{
                        mergedRuntimeConfig.Bandwidth = delegate.BandwidthRequest
                }</span>
                <span class="cov8" title="1">if delegate.IPRequest != nil </span><span class="cov8" title="1">{
                        mergedRuntimeConfig.IPs = delegate.IPRequest
                }</span>
                <span class="cov8" title="1">if delegate.MacRequest != "" </span><span class="cov8" title="1">{
                        mergedRuntimeConfig.Mac = delegate.MacRequest
                }</span>
                <span class="cov8" title="1">if delegate.InfinibandGUIDRequest != "" </span><span class="cov8" title="1">{
                        mergedRuntimeConfig.InfinibandGUID = delegate.InfinibandGUIDRequest
                }</span>
                <span class="cov8" title="1">if delegate.DeviceID != "" </span><span class="cov0" title="0">{
                        mergedRuntimeConfig.DeviceID = delegate.DeviceID
                }</span>
                <span class="cov8" title="1">logging.Debugf("mergeCNIRuntimeConfig: add runtimeConfig for net-attach-def: %v", mergedRuntimeConfig)</span>
        }
        <span class="cov8" title="1">return &amp;mergedRuntimeConfig</span>
}

// CreateCNIRuntimeConf create CNI RuntimeConf for a delegate. If delegate configuration
// exists, merge data with the runtime config.
func CreateCNIRuntimeConf(args *skel.CmdArgs, k8sArgs *K8sArgs, ifName string, rc *RuntimeConfig, delegate *DelegateNetConf) (*libcni.RuntimeConf, string) <span class="cov8" title="1">{
        podName := string(k8sArgs.K8S_POD_NAME)
        podNamespace := string(k8sArgs.K8S_POD_NAMESPACE)
        podUID := string(k8sArgs.K8S_POD_UID)
        sandboxID := string(k8sArgs.K8S_POD_INFRA_CONTAINER_ID)
        return NewCNIRuntimeConf(args.ContainerID, sandboxID, podName, podNamespace, podUID, args.Netns, ifName, rc, delegate)
}</span>

// NewCNIRuntimeConf creates the CNI `RuntimeConf` for the given ADD / DEL request.
func NewCNIRuntimeConf(containerID, sandboxID, podName, podNamespace, podUID, netNs, ifName string, rc *RuntimeConfig, delegate *DelegateNetConf) (*libcni.RuntimeConf, string) <span class="cov8" title="1">{
        logging.Debugf("LoadCNIRuntimeConf: %s, %v %v", ifName, rc, delegate)

        delegateRc := DelegateRuntimeConfig(containerID, delegate, rc, ifName)
        // In part, adapted from K8s pkg/kubelet/dockershim/network/cni/cni.go#buildCNIRuntimeConf
        rt := CreateRuntimeConf(netNs, podNamespace, podName, containerID, sandboxID, podUID, ifName)

        var cniDeviceInfoFile string

        // Populate rt.Args with CNI_ARGS if the rt.Args value is not set
        cniArgs := os.Getenv("CNI_ARGS")
        if cniArgs != "" </span><span class="cov8" title="1">{
                logging.Debugf("ARGS: %s", cniArgs)
                for _, arg := range strings.Split(cniArgs, ";") </span><span class="cov8" title="1">{
                        // SplitN to handle = within values, like BLAH=foo=bar
                        keyval := strings.SplitN(arg, "=", 2)
                        if len(keyval) != 2 </span><span class="cov0" title="0">{
                                logging.Errorf("CreateCNIRuntimeConf: CNI_ARGS %s %s %d is not recognized as CNI arg, skipped", arg, keyval, len(keyval))
                                continue</span>
                        }

                        <span class="cov8" title="1">envKey := string(keyval[0])
                        envVal := string(keyval[1])
                        found := false
                        for i := range rt.Args </span><span class="cov8" title="1">{
                                // Update existing key if its value is empty
                                if rt.Args[i][0] == envKey &amp;&amp; rt.Args[i][1] == "" &amp;&amp; envVal != "" </span><span class="cov8" title="1">{
                                        logging.Debugf("CreateCNIRuntimeConf: add new val: %s", arg)
                                        rt.Args[i][1] = envVal
                                        found = true
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if !found </span><span class="cov8" title="1">{
                                // Add the new key if it didn't exist yet
                                rt.Args = append(rt.Args, [2]string{envKey, envVal})
                        }</span>
                }
        }

        <span class="cov8" title="1">if delegateRc != nil </span><span class="cov8" title="1">{
                cniDeviceInfoFile = delegateRc.CNIDeviceInfoFile
                capabilityArgs := map[string]interface{}{}
                if len(delegateRc.PortMaps) != 0 </span><span class="cov8" title="1">{
                        capabilityArgs["portMappings"] = delegateRc.PortMaps
                }</span>
                <span class="cov8" title="1">if delegateRc.Bandwidth != nil </span><span class="cov0" title="0">{
                        capabilityArgs["bandwidth"] = delegateRc.Bandwidth
                }</span>
                <span class="cov8" title="1">if len(delegateRc.IPs) != 0 </span><span class="cov0" title="0">{
                        capabilityArgs["ips"] = delegateRc.IPs
                }</span>
                <span class="cov8" title="1">if len(delegateRc.Mac) != 0 </span><span class="cov0" title="0">{
                        capabilityArgs["mac"] = delegateRc.Mac
                }</span>
                <span class="cov8" title="1">if len(delegateRc.InfinibandGUID) != 0 </span><span class="cov0" title="0">{
                        capabilityArgs["infinibandGUID"] = delegateRc.InfinibandGUID
                }</span>
                <span class="cov8" title="1">if delegateRc.DeviceID != "" </span><span class="cov0" title="0">{
                        capabilityArgs["deviceID"] = delegateRc.DeviceID
                }</span>
                <span class="cov8" title="1">if delegateRc.CNIDeviceInfoFile != "" </span><span class="cov0" title="0">{
                        capabilityArgs["CNIDeviceInfoFile"] = delegateRc.CNIDeviceInfoFile
                }</span>
                <span class="cov8" title="1">rt.CapabilityArgs = capabilityArgs</span>
        }
        <span class="cov8" title="1">return rt, cniDeviceInfoFile</span>
}

// CreateRuntimeConf creates the CNI `RuntimeConf` for the given ADD / DEL request.
func CreateRuntimeConf(netNs, podNamespace, podName, containerID, sandboxID, podUID, ifName string) *libcni.RuntimeConf <span class="cov8" title="1">{
        return &amp;libcni.RuntimeConf{
                ContainerID: containerID,
                NetNS:       netNs,
                IfName:      ifName,
                // NOTE: Verbose logging depends on this order, so please keep Args order.
                Args: [][2]string{
                        {"IgnoreUnknown", "true"},
                        {"K8S_POD_NAMESPACE", podNamespace},
                        {"K8S_POD_NAME", podName},
                        {"K8S_POD_INFRA_CONTAINER_ID", sandboxID},
                        {"K8S_POD_UID", podUID},
                },
        }
}</span>

// DelegateRuntimeConfig creates the CNI `RuntimeConf` for the given ADD / DEL request.
func DelegateRuntimeConfig(containerID string, delegate *DelegateNetConf, rc *RuntimeConfig, ifName string) *RuntimeConfig <span class="cov8" title="1">{
        var delegateRc *RuntimeConfig

        if delegate != nil </span><span class="cov0" title="0">{
                delegateRc = mergeCNIRuntimeConfig(rc, delegate)
                if delegateRc.DeviceID != "" </span><span class="cov0" title="0">{
                        if delegateRc.CNIDeviceInfoFile != "" </span><span class="cov0" title="0">{
                                logging.Debugf("Warning: Existing value of CNIDeviceInfoFile will be overwritten %s", delegateRc.CNIDeviceInfoFile)
                        }</span>
                        <span class="cov0" title="0">autoDeviceInfo := fmt.Sprintf("%s-%s_%s", delegate.Name, containerID, ifName)
                        delegateRc.CNIDeviceInfoFile = nadutils.GetCNIDeviceInfoPath(autoDeviceInfo)
                        logging.Debugf("Adding auto-generated CNIDeviceInfoFile: %s", delegateRc.CNIDeviceInfoFile)</span>
                }
        } else<span class="cov8" title="1"> {
                delegateRc = rc
        }</span>
        <span class="cov8" title="1">return delegateRc</span>
}

// GetGatewayFromResult retrieves gateway IP addresses from CNI result
func GetGatewayFromResult(result *cni100.Result) []net.IP <span class="cov0" title="0">{
        var gateways []net.IP

        for _, route := range result.Routes </span><span class="cov0" title="0">{
                if mask, _ := route.Dst.Mask.Size(); mask == 0 </span><span class="cov0" title="0">{
                        gateways = append(gateways, route.GW)
                }</span>
        }
        <span class="cov0" title="0">return gateways</span>
}

// LoadNetConf converts inputs (i.e. stdin) to NetConf
func LoadNetConf(bytes []byte) (*NetConf, error) <span class="cov8" title="1">{
        // LogToStderr's default value set to true
        netconf := &amp;NetConf{LogToStderr: true}

        logging.Debugf("LoadNetConf: %s", string(bytes))
        if err := json.Unmarshal(bytes, netconf); err != nil </span><span class="cov8" title="1">{
                return nil, logging.Errorf("LoadNetConf: failed to load netconf: %v", err)
        }</span>

        // Logging
        <span class="cov8" title="1">logging.SetLogStderr(netconf.LogToStderr)
        logging.SetLogOptions(netconf.LogOptions)
        if netconf.LogFile != "" </span><span class="cov8" title="1">{
                logging.SetLogFile(netconf.LogFile)
        }</span>
        <span class="cov8" title="1">if netconf.LogLevel != "" </span><span class="cov8" title="1">{
                logging.SetLogLevel(netconf.LogLevel)
        }</span>

        // Parse previous result
        <span class="cov8" title="1">if netconf.RawPrevResult != nil </span><span class="cov8" title="1">{
                resultBytes, err := json.Marshal(netconf.RawPrevResult)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, logging.Errorf("LoadNetConf: could not serialize prevResult: %v", err)
                }</span>
                <span class="cov8" title="1">res, err := version.NewResult(netconf.CNIVersion, resultBytes)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, logging.Errorf("LoadNetConf: could not parse prevResult: %v", err)
                }</span>
                <span class="cov8" title="1">netconf.RawPrevResult = nil
                netconf.PrevResult, err = cni100.NewResultFromResult(res)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, logging.Errorf("LoadNetConf: could not convert result to current version: %v", err)
                }</span>
        }

        // Delegates must always be set. If no kubeconfig is present, the
        // delegates are executed in-order.  If a kubeconfig is present,
        // at least one delegate must be present and the first delegate is
        // the master plugin. Kubernetes CRD delegates are then appended to
        // the existing delegate list and all delegates executed in-order.

        <span class="cov8" title="1">if len(netconf.RawDelegates) == 0 &amp;&amp; netconf.ClusterNetwork == "" </span><span class="cov8" title="1">{
                return nil, logging.Errorf("LoadNetConf: at least one delegate/clusterNetwork must be specified")
        }</span>

        <span class="cov8" title="1">if netconf.CNIDir == "" </span><span class="cov8" title="1">{
                netconf.CNIDir = defaultCNIDir
        }</span>

        <span class="cov8" title="1">if netconf.ConfDir == "" </span><span class="cov8" title="1">{
                netconf.ConfDir = defaultConfDir
        }</span>

        <span class="cov8" title="1">if netconf.BinDir == "" </span><span class="cov8" title="1">{
                netconf.BinDir = defaultBinDir
        }</span>

        <span class="cov8" title="1">if netconf.ReadinessIndicatorFile == "" </span><span class="cov8" title="1">{
                netconf.ReadinessIndicatorFile = defaultReadinessIndicatorFile
        }</span>

        <span class="cov8" title="1">if len(netconf.SystemNamespaces) == 0 </span><span class="cov8" title="1">{
                netconf.SystemNamespaces = []string{"kube-system"}
        }</span>

        <span class="cov8" title="1">if netconf.MultusNamespace == "" </span><span class="cov8" title="1">{
                netconf.MultusNamespace = defaultMultusNamespace
        }</span>

        // setup namespace isolation
        <span class="cov8" title="1">if netconf.RawNonIsolatedNamespaces == "" </span><span class="cov8" title="1">{
                netconf.NonIsolatedNamespaces = []string{defaultNonIsolatedNamespace}
        }</span> else<span class="cov8" title="1"> {
                // Parse the comma separated list
                nonisolated := strings.Split(netconf.RawNonIsolatedNamespaces, ",")
                // Cleanup the whitespace
                for i, nonv := range nonisolated </span><span class="cov8" title="1">{
                        nonisolated[i] = strings.TrimSpace(nonv)
                }</span>
                <span class="cov8" title="1">netconf.NonIsolatedNamespaces = nonisolated</span>
        }

        // get RawDelegates and put delegates field
        <span class="cov8" title="1">if netconf.ClusterNetwork == "" </span><span class="cov8" title="1">{
                // for Delegates
                if len(netconf.RawDelegates) == 0 </span><span class="cov0" title="0">{
                        return nil, logging.Errorf("LoadNetConf: at least one delegate must be specified")
                }</span>
                <span class="cov8" title="1">for idx, rawConf := range netconf.RawDelegates </span><span class="cov8" title="1">{
                        bytes, err := json.Marshal(rawConf)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, logging.Errorf("LoadNetConf: error marshalling delegate %d config: %v", idx, err)
                        }</span>
                        <span class="cov8" title="1">delegateConf, err := LoadDelegateNetConf(bytes, nil, "", "")
                        if err != nil </span><span class="cov8" title="1">{
                                return nil, logging.Errorf("LoadNetConf: failed to load delegate %d config: %v", idx, err)
                        }</span>
                        <span class="cov8" title="1">netconf.Delegates = append(netconf.Delegates, delegateConf)</span>
                }
                <span class="cov8" title="1">netconf.RawDelegates = nil

                // First delegate is always the master plugin
                netconf.Delegates[0].MasterPlugin = true</span>
        }

        <span class="cov8" title="1">return netconf, nil</span>
}

// LoadDaemonNetConf loads the configuration for the multus daemon
func LoadDaemonNetConf(configPath string) (*ControllerNetConf, []byte, error) <span class="cov0" title="0">{
        config, err := ioutil.ReadFile(configPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("failed to read the config file's contents: %w", err)
        }</span>

        <span class="cov0" title="0">daemonNetConf := &amp;ControllerNetConf{}
        if err := json.Unmarshal(config, daemonNetConf); err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("failed to unmarshall the daemon configuration: %w", err)
        }</span>

        <span class="cov0" title="0">logging.SetLogStderr(daemonNetConf.LogToStderr)
        if daemonNetConf.LogFile != DefaultMultusDaemonConfigFile </span><span class="cov0" title="0">{
                logging.SetLogFile(daemonNetConf.LogFile)
        }</span>
        <span class="cov0" title="0">if daemonNetConf.LogLevel != "" </span><span class="cov0" title="0">{
                logging.SetLogLevel(daemonNetConf.LogLevel)
        }</span>

        <span class="cov0" title="0">if daemonNetConf.CNIDir == "" </span><span class="cov0" title="0">{
                daemonNetConf.CNIDir = defaultCNIDir
        }</span>

        <span class="cov0" title="0">if daemonNetConf.ConfDir == "" </span><span class="cov0" title="0">{
                daemonNetConf.ConfDir = defaultConfDir
        }</span>

        <span class="cov0" title="0">if daemonNetConf.BinDir == "" </span><span class="cov0" title="0">{
                daemonNetConf.BinDir = defaultBinDir
        }</span>

        <span class="cov0" title="0">if daemonNetConf.MultusSocketDir == "" </span><span class="cov0" title="0">{
                daemonNetConf.MultusSocketDir = defaultMultusRunDir
        }</span>

        <span class="cov0" title="0">return daemonNetConf, config, nil</span>
}

// AddDelegates appends the new delegates to the delegates list
func (n *NetConf) AddDelegates(newDelegates []*DelegateNetConf) error <span class="cov0" title="0">{
        logging.Debugf("AddDelegates: %v", newDelegates)
        n.Delegates = append(n.Delegates, newDelegates...)
        return nil
}</span>

// delegateAddDeviceID injects deviceID information in delegate bytes
func delegateAddDeviceID(inBytes []byte, deviceID string) ([]byte, error) <span class="cov8" title="1">{
        var rawConfig map[string]interface{}
        var err error

        err = json.Unmarshal(inBytes, &amp;rawConfig)
        if err != nil </span><span class="cov8" title="1">{
                return nil, logging.Errorf("delegateAddDeviceID: failed to unmarshal inBytes: %v", err)
        }</span>
        // Inject deviceID
        <span class="cov8" title="1">rawConfig["deviceID"] = deviceID
        rawConfig["pciBusID"] = deviceID
        configBytes, err := json.Marshal(rawConfig)
        if err != nil </span><span class="cov0" title="0">{
                return nil, logging.Errorf("delegateAddDeviceID: failed to re-marshal Spec.Config: %v", err)
        }</span>
        <span class="cov8" title="1">logging.Debugf("delegateAddDeviceID updated configBytes %s", string(configBytes))
        return configBytes, nil</span>
}

// addDeviceIDInConfList injects deviceID information in delegate bytes
func addDeviceIDInConfList(inBytes []byte, deviceID string) ([]byte, error) <span class="cov8" title="1">{
        var rawConfig map[string]interface{}
        var err error

        err = json.Unmarshal(inBytes, &amp;rawConfig)
        if err != nil </span><span class="cov8" title="1">{
                return nil, logging.Errorf("addDeviceIDInConfList: failed to unmarshal inBytes: %v", err)
        }</span>

        <span class="cov8" title="1">pList, ok := rawConfig["plugins"]
        if !ok </span><span class="cov0" title="0">{
                return nil, logging.Errorf("addDeviceIDInConfList: unable to get plugin list")
        }</span>

        <span class="cov8" title="1">pMap, ok := pList.([]interface{})
        if !ok </span><span class="cov0" title="0">{
                return nil, logging.Errorf("addDeviceIDInConfList: unable to typecast plugin list")
        }</span>

        <span class="cov8" title="1">for idx, plugin := range pMap </span><span class="cov8" title="1">{
                currentPlugin, ok := plugin.(map[string]interface{})
                if !ok </span><span class="cov0" title="0">{
                        return nil, logging.Errorf("addDeviceIDInConfList: unable to typecast plugin #%d", idx)
                }</span>
                // Inject deviceID
                <span class="cov8" title="1">currentPlugin["deviceID"] = deviceID
                currentPlugin["pciBusID"] = deviceID</span>
        }

        <span class="cov8" title="1">configBytes, err := json.Marshal(rawConfig)
        if err != nil </span><span class="cov0" title="0">{
                return nil, logging.Errorf("addDeviceIDInConfList: failed to re-marshal: %v", err)
        }</span>
        <span class="cov8" title="1">logging.Debugf("addDeviceIDInConfList: updated configBytes %s", string(configBytes))
        return configBytes, nil</span>
}

// injectCNIArgs injects given args to cniConfig
func injectCNIArgs(cniConfig *map[string]interface{}, args *map[string]interface{}) error <span class="cov8" title="1">{
        if argsval, ok := (*cniConfig)["args"]; ok </span><span class="cov8" title="1">{
                argsvalmap := argsval.(map[string]interface{})
                if cnival, ok := argsvalmap["cni"]; ok </span><span class="cov8" title="1">{
                        cnivalmap := cnival.(map[string]interface{})
                        // merge it if conf has args
                        for key, val := range *args </span><span class="cov8" title="1">{
                                cnivalmap[key] = val
                        }</span>
                } else<span class="cov0" title="0"> {
                        argsvalmap["cni"] = *args
                }</span>
        } else<span class="cov8" title="1"> {
                argsval := map[string]interface{}{}
                argsval["cni"] = *args
                (*cniConfig)["args"] = argsval
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// addCNIArgsInConfig injects given cniArgs to CNI config in inBytes
func addCNIArgsInConfig(inBytes []byte, cniArgs *map[string]interface{}) ([]byte, error) <span class="cov8" title="1">{
        var rawConfig map[string]interface{}
        var err error

        err = json.Unmarshal(inBytes, &amp;rawConfig)
        if err != nil </span><span class="cov0" title="0">{
                return nil, logging.Errorf("addCNIArgsInConfig(): failed to unmarshal inBytes: %v", err)
        }</span>

        <span class="cov8" title="1">injectCNIArgs(&amp;rawConfig, cniArgs)

        configBytes, err := json.Marshal(rawConfig)
        if err != nil </span><span class="cov0" title="0">{
                return nil, logging.Errorf("addCNIArgsInConfig(): failed to re-marshal: %v", err)
        }</span>
        <span class="cov8" title="1">return configBytes, nil</span>
}

// addCNIArgsInConfList injects given cniArgs to CNI conflist in inBytes
func addCNIArgsInConfList(inBytes []byte, cniArgs *map[string]interface{}) ([]byte, error) <span class="cov8" title="1">{
        var rawConfig map[string]interface{}
        var err error

        err = json.Unmarshal(inBytes, &amp;rawConfig)
        if err != nil </span><span class="cov0" title="0">{
                return nil, logging.Errorf("addCNIArgsInConfList(): failed to unmarshal inBytes: %v", err)
        }</span>

        <span class="cov8" title="1">pList, ok := rawConfig["plugins"]
        if !ok </span><span class="cov0" title="0">{
                return nil, logging.Errorf("addCNIArgsInConfList(): unable to get plugin list")
        }</span>

        <span class="cov8" title="1">pMap, ok := pList.([]interface{})
        if !ok </span><span class="cov0" title="0">{
                return nil, logging.Errorf("addCNIArgsInConfList(): unable to typecast plugin list")
        }</span>

        <span class="cov8" title="1">for idx := range pMap </span><span class="cov8" title="1">{
                valMap := pMap[idx].(map[string]interface{})
                injectCNIArgs(&amp;valMap, cniArgs)
        }</span>

        <span class="cov8" title="1">configBytes, err := json.Marshal(rawConfig)
        if err != nil </span><span class="cov0" title="0">{
                return nil, logging.Errorf("addCNIArgsInConfList(): failed to re-marshal: %v", err)
        }</span>
        <span class="cov8" title="1">return configBytes, nil</span>
}

// CheckGatewayConfig check gatewayRequest and mark IsFilter{V4,V6}Gateway flag if
// gw filtering is required
func CheckGatewayConfig(delegates []*DelegateNetConf) error <span class="cov0" title="0">{

        v4Gateways := 0
        v6Gateways := 0

        // Check the gateway
        for _, delegate := range delegates </span><span class="cov0" title="0">{
                for _, gw := range delegate.GatewayRequest </span><span class="cov0" title="0">{
                        if gw.To4() != nil </span><span class="cov0" title="0">{
                                v4Gateways++
                        }</span> else<span class="cov0" title="0"> {
                                v6Gateways++
                        }</span>
                }
        }

        <span class="cov0" title="0">if v4Gateways &gt; 1 || v6Gateways &gt; 1 </span><span class="cov0" title="0">{
                return fmt.Errorf("multus does not support ECMP for default-route")
        }</span>

        // set filter flag for each delegate
        <span class="cov0" title="0">for i, delegate := range delegates </span><span class="cov0" title="0">{
                // no GatewayRequest
                if delegate.GatewayRequest == nil </span><span class="cov0" title="0">{
                        delegates[i].IsFilterV4Gateway = true
                        delegates[i].IsFilterV6Gateway = true
                }</span> else<span class="cov0" title="0"> {
                        for _, gw := range delegate.GatewayRequest </span><span class="cov0" title="0">{
                                if gw.To4() != nil </span><span class="cov0" title="0">{
                                        delegates[i].IsFilterV6Gateway = true
                                }</span> else<span class="cov0" title="0"> {
                                        delegates[i].IsFilterV4Gateway = true
                                }</span>
                        }
                }
        }
        <span class="cov0" title="0">return nil</span>
}

// CheckSystemNamespaces checks whether given namespace is in systemNamespaces or not.
func CheckSystemNamespaces(namespace string, systemNamespaces []string) bool <span class="cov8" title="1">{
        for _, nsname := range systemNamespaces </span><span class="cov8" title="1">{
                if namespace == nsname </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
